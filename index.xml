<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Even - A super concise theme for Hugo</title><link>http://wellcheng.github.io/</link><description>Recent content on Even - A super concise theme for Hugo</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 07 Oct 2022 19:06:01 +0800</lastBuildDate><atom:link href="http://wellcheng.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Hugo 重新驱动博客系统</title><link>http://wellcheng.github.io/post/new-hugo-blog-with-even-theme/</link><pubDate>Fri, 07 Oct 2022 19:06:01 +0800</pubDate><guid>http://wellcheng.github.io/post/new-hugo-blog-with-even-theme/</guid><description>Hugo 是开源的流行 GitHub Pages 博客搭建服务 https://gohugo.io/getting-started/quick-start/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 brew install hugo hugo new site charvel-blog cd charvel-blog git init git submodule add https://github.com/olOwOlo/hugo-theme-even themes/even echo theme = \&amp;#34;even\&amp;#34; &amp;gt;&amp;gt; config.toml hugo new posts/new-hugo-blog-with-even-theme.md</description></item><item><title>随便说 iOS 中的 runtime</title><link>http://wellcheng.github.io/post/2017-10-runtime/</link><pubDate>Sun, 19 Nov 2017 18:24:28 +0800</pubDate><guid>http://wellcheng.github.io/post/2017-10-runtime/</guid><description>Objc 作为动态语言，可以将消息转发给想要的对象去处理。但是编译器能做的只有将代码转为汇编指令，然后固定的指令流水执行。因此在 Objecive-C 中，还有一套强大的</description></item><item><title>使用 iOS 中不一样的 NSNotification Center</title><link>http://wellcheng.github.io/post/2017-09-nsnotificaiton/</link><pubDate>Sat, 09 Sep 2017 12:14:36 +0800</pubDate><guid>http://wellcheng.github.io/post/2017-09-nsnotificaiton/</guid><description>通知中心利用观察者模式，能够很方便地进行一对多的通知，通俗点称作广播。 NSNotification default Center 内部维护了观察列表，并负责通知的派发。 使用 Notification 并不难，Foudat</description></item><item><title>使用 LLDB 调试 iOS</title><link>http://wellcheng.github.io/post/2017-08-lldb/</link><pubDate>Fri, 18 Aug 2017 21:10:26 +0800</pubDate><guid>http://wellcheng.github.io/post/2017-08-lldb/</guid><description>一些基础知识 增加断点 使用 b 后面加上 selector，就可以增加一个断点，lldb 会打印断点的编号、描述以及断点的内存地址。 1 2 3 (lldb) b -[NSView hitTest:] Breakpoint 1:</description></item><item><title>iOS 中的多线程</title><link>http://wellcheng.github.io/post/2017-07-threadprogrammingguide-1/</link><pubDate>Wed, 12 Jul 2017 11:10:26 +0800</pubDate><guid>http://wellcheng.github.io/post/2017-07-threadprogrammingguide-1/</guid><description>线程的使用 在常见的多线程模型中，进程即一个运行着多个线程的程序。 线程可以理解为一条独立的代码路径，在线程中，代码一行一行执行。 线程在使用上，</description></item><item><title>常用排序算法：快速排序算法</title><link>http://wellcheng.github.io/post/2017-07-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link><pubDate>Sun, 02 Jul 2017 18:10:26 +0800</pubDate><guid>http://wellcheng.github.io/post/2017-07-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid><description>快速排序算法，简称快排，其应用了递归的思想，现选择一个基准值 baseValue，然后利用这个 baseValue 将代排序的序列分割为两部分，左边是小于 base 的，右</description></item><item><title>在 AutoLayout 和 Masonry 中使用动画</title><link>http://wellcheng.github.io/post/2017-06-use-animation-in-auto-layout-and-masonry/</link><pubDate>Wed, 14 Jun 2017 23:04:39 +0000</pubDate><guid>http://wellcheng.github.io/post/2017-06-use-animation-in-auto-layout-and-masonry/</guid><description>&lt;p>动画是 iOS 中非常重要的一部分，它给用户展现出应用灵气的一面。&lt;/p>
&lt;h2 id="在动画块中修改-frame">在动画块中修改 Frame&lt;/h2>
&lt;p>在原来使用 frame 布局时，在 UIView 的 animate block 中对 view 的布局进行修改，动画即可生效。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">[UIView animte ... {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> view.frame = ...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="autolayout-没有-frame-时如何做动画">AutoLayout 没有 Frame 时如何做动画&lt;/h2>
&lt;p>在 AutoLayout 中，view 的布局等属性都是由约束 constraint 决定，Apple 也不建议在使用 AutoLayout 直接修改 view 的 frame。&lt;/p>
&lt;p>在介绍之前，先看一下 UIView 的 &lt;code>layoutIfNeeded&lt;/code> 方法：&lt;/p></description></item><item><title>Auto Layout 中的 setNeedsUpdateConstraints 和 layoutIfNeeded</title><link>http://wellcheng.github.io/post/2017-05-auto-layout-setneedsupdateconstraints-layoutifneeded/</link><pubDate>Sun, 14 May 2017 23:03:01 +0000</pubDate><guid>http://wellcheng.github.io/post/2017-05-auto-layout-setneedsupdateconstraints-layoutifneeded/</guid><description>&lt;p>先抛出结论：&lt;/p>
&lt;p>&lt;code>setNeedsUpdateConstraints&lt;/code> 保证之后肯定会调用 &lt;code>updateConstraintsIfNeeded&lt;/code> .&lt;/p>
&lt;p>&lt;code>SetNeedsLayout&lt;/code> 保证之后肯定会调用 &lt;code>layoutIfNeeded&lt;/code> .&lt;/p>
&lt;h2 id="autolayout-的本质">AutoLayout 的本质&lt;/h2>
&lt;blockquote>
&lt;p>AutoLayout 是指，用一套规则（约束）来定义视图之间的位置。&lt;/p>
&lt;p>AutoLayout 能够让每个 view 有唯一的 frame。&lt;/p>
&lt;/blockquote>
&lt;p>其实，这样子解释，还是让人很难理解，所以接下来会简单介绍下 AutoLayout ，在对其有所了解和深入后，再解释下面这几个问题：&lt;/p>
&lt;ul>
&lt;li>&lt;code>保证之后调用&lt;/code> 的之后是在什么时候？&lt;/li>
&lt;li>这些方法的调用时序大概是怎么样的？&lt;/li>
&lt;li>为什么要先 set 一下，而不是直接 updateConstraint 和 layout&lt;/li>
&lt;/ul></description></item><item><title>iOS 目录结构</title><link>http://wellcheng.github.io/post/2016-09-ios-project-structure/</link><pubDate>Sat, 24 Sep 2016 22:38:13 +0000</pubDate><guid>http://wellcheng.github.io/post/2016-09-ios-project-structure/</guid><description>&lt;p>最近整理了下工程的目录结构，有一些体会，现在写出来&lt;/p></description></item><item><title>Swift 中闭包 closure 的对象捕获</title><link>http://wellcheng.github.io/post/2016-09-swift-closure-capture/</link><pubDate>Wed, 14 Sep 2016 22:32:18 +0000</pubDate><guid>http://wellcheng.github.io/post/2016-09-swift-closure-capture/</guid><description>&lt;p>在 swift 中，closure 可以捕获当前作用域中的变量，并且持有它。&lt;/p>
&lt;p>函数是闭包的一种，因此函数也是可以持有变量的。&lt;/p></description></item><item><title>Swift 中的错误处理：try, try?, try!</title><link>http://wellcheng.github.io/post/2016-08-about-swift-try/</link><pubDate>Wed, 24 Aug 2016 21:59:29 +0000</pubDate><guid>http://wellcheng.github.io/post/2016-08-about-swift-try/</guid><description>&lt;p>错误处理（Error Handing）是很多语言都有的特性，程序中避免不了会出现错误或者异常的情况，我们需要对于这些「非期望」发生的错误进行正确的处理。本文很简单的将 Objective-C 和 Swift 中的错误处理做一点描述，描述一下自己的想法。&lt;/p></description></item><item><title>iOS 应用状态详解</title><link>http://wellcheng.github.io/post/2016-07-ios-application-state/</link><pubDate>Fri, 15 Jul 2016 20:12:06 +0000</pubDate><guid>http://wellcheng.github.io/post/2016-07-ios-application-state/</guid><description>iOS 应用状态详解 iOS 与其他操作系统有很多不同，当 App 不在当前运行时，可以使用的资源特别有限。 虽说 App 传统上讲只有两种状态，前台和后台。但是这种说法是</description></item><item><title>WWDC 2016 Session 205 - What's new in CocoaTouch 总结</title><link>http://wellcheng.github.io/post/2017-06-what-new-in-cocoatouch/</link><pubDate>Sat, 25 Jun 2016 17:03:22 +0000</pubDate><guid>http://wellcheng.github.io/post/2017-06-what-new-in-cocoatouch/</guid><description>今天的 Session 将主要将四件事情： 你可能已经在 App 中使用的一些核心技巧，我们会讨论如何使用它们构建更好的 App 讨论如何通过 UIKit 和其他一些 API 构建更好的用户界面</description></item><item><title>iOS 并发编程指南(五)-将现有代码迁移为可并发</title><link>http://wellcheng.github.io/post/2015-05-12-ios-bing-fa-bian-cheng-zhi-nan-wu-jiang-xian-you-dai-ma-qian-yi-wei-ke-bing-fa/</link><pubDate>Tue, 12 May 2015 23:20:49 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-05-12-ios-bing-fa-bian-cheng-zhi-nan-wu-jiang-xian-you-dai-ma-qian-yi-wei-ke-bing-fa/</guid><description>&lt;p>将现有的代码迁移至可并发，例如 GCD 或 NSOperation ，有很多办法，尽管可能不是所有的代码都需要迁移，但是部分迁移能够提升程序性能：&lt;/p>
&lt;ul>
&lt;li>使用dispatch queue和Operaiton queue相比线程拥有许多优点：&lt;/li>
&lt;li>应用不再需要存储线程栈到内存空间&lt;/li>
&lt;li>消除了创建和配置线程的代码&lt;/li>
&lt;li>消除了管理和调度线程工作的代码&lt;/li>
&lt;li>简化了你要编写的代码&lt;/li>
&lt;/ul>
&lt;p>本章节主要提供一些迁移相关的 tips&lt;/p></description></item><item><title>iOS 并发编程指南(四)-Dispatch Sources</title><link>http://wellcheng.github.io/post/2015-05-08-ios-bing-fa-bian-cheng-zhi-nan-si-dispatch-sources/</link><pubDate>Fri, 08 May 2015 10:38:38 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-05-08-ios-bing-fa-bian-cheng-zhi-nan-si-dispatch-sources/</guid><description>&lt;p>每当你与系统底层进行交互时，你必须要做好这种任务可能会大量耗时的准备。跟在自己的进程内相比较，调用内核或者其他系统层次涉及到的改变是相当耗时的。因为这些原因，许多系统的库都提供了异步的 API，允许你的代码向系统提交请求后继续做别的工作，这时请求仍在进行中。GCD 就是依据这种方式，允许你提交请求，并且使用 block 和调度队列来回调请求结果。&lt;/p></description></item><item><title>Swift 学习笔记（二）</title><link>http://wellcheng.github.io/post/2015-05-02-swift-xue-xi-bi-ji-2/</link><pubDate>Sat, 02 May 2015 19:23:20 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-05-02-swift-xue-xi-bi-ji-2/</guid><description>&lt;p>今天学习一些基本运算符想关的知识。运算符是检查、改变、合并值的特殊符号或短语。&lt;/p>
&lt;p>另一个很重要的地方是将以前变成容易因为运算法导致的问题解决了一哈。增加了区间运算符，还加入了 OC 中没有的运算符重载&lt;/p></description></item><item><title>iOS 并发编程指南(三)-Dispatch Queues</title><link>http://wellcheng.github.io/post/2015-04-30-ios-bing-fa-bian-cheng-zhi-nan-san-dispatch-queues/</link><pubDate>Thu, 30 Apr 2015 20:48:38 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-04-30-ios-bing-fa-bian-cheng-zhi-nan-san-dispatch-queues/</guid><description>&lt;p>GCD 调度队列是执行任务的强大工具，可以使用同步或异步方式执行任意的代码块。调度队列可以执行几乎所有的单线程代码。相比于线程代码，其更易于使用，且效率要高。&lt;/p>
&lt;p>本章将介绍调度队列，以及如何使用它执行大多数任务。&lt;/p>
&lt;h2 id="dispatch-queue-介绍">Dispatch Queue 介绍&lt;/h2>
&lt;p>调度队列是在程序中执行同步或异步代码的比较简单的一种方式，任务就是程序中需要执行的一些简单的工作。举个🌰，比如执行一些计算，创建或者修改一个数据结构，从文件中读取数据进行处理，等等这样的一些工作。你通过在函数或 block 中写入相应的代码来定义任务，然后将其添加至调度队列。&lt;/p>
&lt;p>调度队列是一种类似对象的结构，管理你提交给它的任务。所有的调度队列都是先进先出（FIFO）的，因此任务开始执行的顺序与添加顺序一致。GCD 已经提供了一些常用的调度队列，你也可以根据需求创建新的调度队列。下面的表列出了几种调度队列，并做了简要的说明&lt;/p></description></item><item><title>AutoLayout 读书笔记(三)-可视化格式</title><link>http://wellcheng.github.io/post/2015-04-30-autolayout-du-shu-bi-ji-san-ke-shi-hua-ge-shi/</link><pubDate>Thu, 30 Apr 2015 14:22:42 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-04-30-autolayout-du-shu-bi-ji-san-ke-shi-hua-ge-shi/</guid><description>&lt;p>AutoLayout 目前有三种创建约束的方式，第一种为 IB 中手动创建、第二种为代码中使用 NSLayoutConstraint 类，现在我们学习第三种，使用 &lt;code>格式化语言&lt;/code> 创建约束。&lt;/p>
&lt;p>需要记住的是，不管何种方式创建的约束，都是 NSLayoutConstraint 类的实例，并且遵循 &lt;code>y = mx + b&lt;/code> 关系&lt;/p>
&lt;h2 id="可视化约束的格式介绍">可视化约束的格式介绍&lt;/h2>
&lt;p>NSLayoutConstraint 类方法创建可视化的约束，尽管可视化约束的内容能够关联多个视图，但是它们会被 NSLayoutConstraint 翻译为每次只关联一个或多个视图。这种方式创建的约束为数组的形式。&lt;/p></description></item><item><title>Swift 学习笔记(一)</title><link>http://wellcheng.github.io/post/2015-04-29-swift-xue-xi-bi-ji-1/</link><pubDate>Wed, 29 Apr 2015 19:22:58 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-04-29-swift-xue-xi-bi-ji-1/</guid><description>&lt;blockquote>
&lt;p>swift 这门语言一直想取深入了解下，苦于时间少，现在快毕业了，呆在学校时间还算比较充足，所以开始学习一哈。&lt;/p>
&lt;/blockquote></description></item><item><title>iOS 并发编程指南（二）- Operation Queue</title><link>http://wellcheng.github.io/post/2015-04-27-ios-bing-fa-bian-cheng-zhi-nan-er--operation-queue/</link><pubDate>Mon, 27 Apr 2015 10:58:41 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-04-27-ios-bing-fa-bian-cheng-zhi-nan-er--operation-queue/</guid><description>&lt;p>Cocoa operations 通过面向对象的方式封装了执行异步操作的工作。operations 是设计用来连接 operation queue。因为它们是基于 Objective-C 的，operations 常用于 iOS 和 OS X 中。&lt;/p>
&lt;p>本章节描述了如何定义和使用 operations&lt;/p></description></item><item><title>AutoLayout 读书笔记(二)</title><link>http://wellcheng.github.io/post/2015-04-23-autolayout-du-shu-bi-ji-er/</link><pubDate>Thu, 23 Apr 2015 09:00:52 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-04-23-autolayout-du-shu-bi-ji-er/</guid><description>&lt;h2 id="约束">约束&lt;/h2>
&lt;p>AutoLayout 是一种约束满足系统，约束的本质就是&lt;code>限制&lt;/code>,布局中，创建的每一个规则都提出一个要求，这些要求规定了视图中一个部分与另一个部分之间的关系，这些规定具有优先级，AutoLayout 系统根据所有的规则，确定唯一的布局方式。&lt;/p></description></item><item><title>AutoLayout 读书笔记(一)</title><link>http://wellcheng.github.io/post/2015-04-22-autolayout-du-shu-bi-ji-1/</link><pubDate>Wed, 22 Apr 2015 21:34:19 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-04-22-autolayout-du-shu-bi-ji-1/</guid><description>&lt;h2 id="第一章-autolayout-介绍">第一章 AutoLayout 介绍&lt;/h2>
&lt;p>###1.1 由来：&lt;/p>
&lt;p>前身为 Cassowary 约束解析工具包，本质是通过定义的约束构成联立方程组，然后求解，得出界面元素唯一的布局可能。&lt;/p>
&lt;p>###1.2 好处都有啥？&lt;/p>
&lt;p>&lt;strong>几何关系&lt;/strong>&lt;/p>
&lt;p>工作原理为通过创建界面上元素之间的关系从而实现布局。对于自然界之间的一些关系，可以用一些统一的规则来描述，能够建立界面元素之间强健的几何关系，在一定程度上使用抽象的语言描述。&lt;/p>
&lt;p>改变 AutoLayout 约束的值，还可以创建出优美的动画。&lt;/p></description></item><item><title>创建自己的cocoaPods - podspec 文件</title><link>http://wellcheng.github.io/post/2015-04-04-chuang-jian-zi-ji-de-cocoapods-podspec-wen-jian/</link><pubDate>Sat, 04 Apr 2015 20:23:36 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-04-04-chuang-jian-zi-ji-de-cocoapods-podspec-wen-jian/</guid><description>&lt;blockquote>
&lt;p>现在很多开源的第三方库都支持 cocoaPods 来管理，这对于 iOS 开发人员来说是一个福音，基础的运用为创建 &lt;code>podfile&lt;/code> 然后在文件中加入自己需要依赖的第三方库就可以啦。不过在实际的使用中，有可能需要依赖自己的库或者公司的库，或者有些库没有加入到 cocoaPods 中，这个时候就需要我们制定自己的 cocoaPods 库了。&lt;/p>
&lt;/blockquote></description></item><item><title>iOS 并发编程指南(一)</title><link>http://wellcheng.github.io/post/2015-03-09-ios-bing-fa-bian-cheng-zhi-nan-1/</link><pubDate>Mon, 09 Mar 2015 15:38:28 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-03-09-ios-bing-fa-bian-cheng-zhi-nan-1/</guid><description>&lt;blockquote>
&lt;p>本文为翻译苹果官方文档，旨在自我学习，翻译之处会有坑，请酌情参考&lt;/p>
&lt;/blockquote>
&lt;h2 id="简介">简介&lt;/h2>
&lt;p>并发是指多件事情同时发生。随着多核 CPU 的实现，每个处理器上的核心只会增加，开发人员需要新的方式来充分利用它们。尽管像 OS X 和 iOS 这样的操作系统（自卖自夸，别的 OS 被你吃了吗？）能够并行的运行多个程序，其中大多数的程序运行在后台，并且经常需要一小段 CPU 时间来执行任务。运行在前台的程序与用户交互并且占用大量的 CPU 时间。如果一个程序有很多任务去做但是只有一部分内核可以使用，那么额外的计算资源将被浪费。&lt;/p>
&lt;p>在过去，在程序中引入并发需要创建额外的一个或多个线程。不幸的是，写线程级别的代码很具有挑战性。线程是很底层的工具，必须手动来管理。对于一个程序，由于线程的最佳数目基于系统负载和底层硬件动态改变，实现一个正确的线程解决方案是非常困难的。此外，线程的同步机制通常会给软件设计增加复杂性和带来风险，并不能保证一定会提高程序性能。&lt;/p>
&lt;p>相比较传统的基于线程的系统和应用程序，OS X 和 iOS 更多地采用异步方法来执行并行的任务。应用程序只需要定义特定的任务，然后让系统执行它们，而不是直接创建线程。通过让操作系统来管理线程，使得应用程序具有了原生线程不可能带来的可扩展性。开发者也有了更加简单高效的编程模式。&lt;/p>
&lt;p>本文档描述了并发编程的技术和技巧，使用与 OS X 和 iOS。&lt;/p>
&lt;p>文档包含以下章节：&lt;/p>
&lt;ul>
&lt;li>并行和程序设计：介绍了基本的异步程序设计和异步执行自定义任务的技巧&lt;/li>
&lt;li>Operation Queues（操作队列）：指出如何使用 Objective-C 对象封装任务并且执行&lt;/li>
&lt;li>Dispatch Queue（分发队列）：如何并行的执行任务在 C 语言编程中&lt;/li>
&lt;li>Dispatch Sources：如何异步的处理系统时间&lt;/li>
&lt;li>Migrating Away from Threads：介绍如何将已存在的基于线程的代码迁移至新的技术上。&lt;/li>
&lt;/ul></description></item><item><title>将你的iOS 工程转换为支持64位的版本</title><link>http://wellcheng.github.io/post/2015-03-05-jiang-ni-de-ios-gong-cheng-zhuan-huan-wei-zhi-chi-64wei-de-ban-ben/</link><pubDate>Thu, 05 Mar 2015 15:21:41 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-03-05-jiang-ni-de-ios-gong-cheng-zhuan-huan-wei-zhi-chi-64wei-de-ban-ben/</guid><description>&lt;p>总的来说，可以根据以下步骤创建一个同时支持32位和64位运行环境的 App:&lt;/p>
&lt;ol>
&lt;li>确保 Xcode 版本至少为 5.0.1&lt;/li>
&lt;li>打开你的项目，Xcode 提示适配你的工程，编译64位版本的时候可能会给你提出一些重要的警告或者错误。&lt;/li>
&lt;li>设置你的项目最低为 iOS 5.1.1, iOS 5.1 之前的系统不支持64位&lt;/li>
&lt;li>修改工程的编译指令集为 “Standard Architectures”，即 Xcode 默认版本，其中包括 ARMv7 和 ARM64&lt;/li>
&lt;li>更新你的 App 以支持64位运行环境，编译器发出的警告和错误能够引导你处理整个过程，但是 Xcode 不是万能的，你还需要根据本文档来做一些事情。&lt;/li>
&lt;li>在 64 位的真机上测试你的 App，模拟器也可以帮助你测试，但是可能有一部分问题只有在真机上才会出现。&lt;/li>
&lt;li>使用 Instruments 来分析内存消耗以及性能。&lt;/li>
&lt;li>提交支持32位和64位的 App&lt;/li>
&lt;/ol>
&lt;p>接下来的内容会陈列一些在转换过程中经常出现的问题，根据引导仔细检查你的代码。&lt;/p></description></item><item><title>iOS 工程中的 Architectures</title><link>http://wellcheng.github.io/post/2015-03-02-ios-gong-cheng-zhong-de-architectures/</link><pubDate>Mon, 02 Mar 2015 11:05:58 +0800</pubDate><guid>http://wellcheng.github.io/post/2015-03-02-ios-gong-cheng-zhong-de-architectures/</guid><description>&lt;h2 id="arm-是什么">Arm 是什么&lt;/h2>
&lt;p>Arm 处理器是 Arm 公司面向市场推出的 RISC(精简指令集) 微处理器，目前手机上的 CPU 都是 RISC 类型，跟传统 PC 端的 CPU(CISC) 相比，具有体积小、低功耗、低成本、高性能的特点，很适合于移动终端。一般电脑上的 CPU 都是 CISC 类型的，iOS 模拟器是将 Arm 指令转换后在 X86 上运行。另外，Apple 本身就是 ARM 最大的股东之一。&lt;/p></description></item><item><title/><link>http://wellcheng.github.io/post/2015-11-scrollview-%E4%B8%AD%E4%BD%BF%E7%94%A8-autolayout-%E7%9A%84%E5%9D%91%E4%B8%8E%E5%A1%AB%E5%9D%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://wellcheng.github.io/post/2015-11-scrollview-%E4%B8%AD%E4%BD%BF%E7%94%A8-autolayout-%E7%9A%84%E5%9D%91%E4%B8%8E%E5%A1%AB%E5%9D%91/</guid><description>&lt;p>title: ScrollView 中使用 autoLayout 的坑与填坑
date: 2015-11-13 14:00:25
categories:&lt;/p>
&lt;ul>
&lt;li>iOS
tags: [ScrollView, autoLayout]&lt;/li>
&lt;/ul>
&lt;hr>
&lt;blockquote>
&lt;p>ScrollView 是 UIKit 中很重要的一个组件，TableView 和 UIWebView 等很多涉及到滑动的视图都有它的影子，在之前使用代码布局的时代，只要简单的进行配置，就 OK 了。但是在 AutoLayout 的时代，ScrollView 就存在了很多坑，今天就是分析坑和填坑的。&lt;/p>
&lt;/blockquote></description></item><item><title/><link>http://wellcheng.github.io/post/2015-year-end-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://wellcheng.github.io/post/2015-year-end-summary/</guid><description>&lt;h2 id="tags">title: 2015 年终总结
date: 2016-01-01 15:07:21
tags:&lt;/h2>
&lt;p>2015年已经过去了，现在好像比较流行弄啥子年终总结，我也凑个热闹。&lt;/p>
&lt;p>2014 年 11 月 11 日入职百度，做 iOS 实习生。之前的实习入职面试也是故事颇多，总得来说还是比较幸运的，遇到了很好的 leader 和 team。&lt;/p>
&lt;p>15 年初，学习 iOS 当时已经有半年了，虽然是断断续续自学的半年，但是一路上还是学的比较辛苦。其中的过程等之后有时间再总结下自己的学习之旅。&lt;/p></description></item><item><title/><link>http://wellcheng.github.io/post/2017-01-abount-gdc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://wellcheng.github.io/post/2017-01-abount-gdc/</guid><description>&lt;h2 id="date-2017-01-19-224822">title: GCD 的一点疑惑与自解
date: 2017-01-19 22:48:22&lt;/h2>
&lt;h1 id="gcd-的一点疑惑与自解">GCD 的一点疑惑与自解&lt;/h1>
&lt;p>GCD 其实已经了解了很久了，在实际工程中也会经常用，但是其实很多实践都是浅尝辄止。&lt;/p>
&lt;p>最近又在回头看这块儿的内容，有一些知识点，原来不甚明白的，现在有了新的认识，刚好也记录下。&lt;/p>
&lt;p>GCD 是一套方案，GCD 本身管理了一组线程池，GCD 负责线程池中的线程创建销毁、并且这种能力是动态化的，即可以充分利用当前 CPU 的多核特性。
添加到 GCD 队列中的任务，会由 GCD 来决定运行在哪一个线程上。也就是说，GCD Queue 是一个抽象概念， task 是添加到 Queue 中不假，但是实际仍然是运行在线程上的。&lt;/p></description></item></channel></rss>