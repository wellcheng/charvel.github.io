<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>将你的iOS 工程转换为支持64位的版本 | Charvel 互联网自留地</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="总的来说，可以根据以下步骤创建一个同时支持32位和64位运行环境的 App:

确保 Xcode 版本至少为 5.0.1
打开你的项目，Xcode 提示适配你的工程，编译64位版本的时候可能会给你提出一些重要的警告或者错误。
设置你的项目最低为 iOS 5.1.1, iOS 5.1 之前的系统不支持64位
修改工程的编译指令集为 “Standard Architectures”，即 Xcode 默">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="将你的iOS 工程转换为支持64位的版本 | Charvel 互联网自留地">
    <meta name="twitter:description" content="总的来说，可以根据以下步骤创建一个同时支持32位和64位运行环境的 App:

确保 Xcode 版本至少为 5.0.1
打开你的项目，Xcode 提示适配你的工程，编译64位版本的时候可能会给你提出一些重要的警告或者错误。
设置你的项目最低为 iOS 5.1.1, iOS 5.1 之前的系统不支持64位
修改工程的编译指令集为 “Standard Architectures”，即 Xcode 默">

    <meta property="og:type" content="article">
    <meta property="og:title" content="将你的iOS 工程转换为支持64位的版本 | Charvel 互联网自留地">
    <meta property="og:description" content="总的来说，可以根据以下步骤创建一个同时支持32位和64位运行环境的 App:

确保 Xcode 版本至少为 5.0.1
打开你的项目，Xcode 提示适配你的工程，编译64位版本的时候可能会给你提出一些重要的警告或者错误。
设置你的项目最低为 iOS 5.1.1, iOS 5.1 之前的系统不支持64位
修改工程的编译指令集为 “Standard Architectures”，即 Xcode 默">

    
    <meta name="author" content="Well Cheng">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Charvel 互联网自留地" href="/atom.xml">
    

    <link rel="canonical" href="http://blog.devcheng.com/2015/03/05/2015-03-05-jiang-ni-de-ios-gong-cheng-zhuan-huan-wei-zhi-chi-64wei-de-ban-ben/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Charvel 互联网自留地 的主页"><img src="/images/avatar.jpg" width="80" alt="Charvel 互联网自留地 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Charvel 互联网自留地">Charvel 互联网自留地</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">记录生活的点点滴滴，记录技术的淅淅沥沥</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/favourite">黄金屋</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/monniya" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/onlymonniya" title="Twitter" target="_blank">
      <i class="social fa fa-twitter"></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:chengwei3269@hotmail.com" title="Mail" target="_blank">
      <i class="social fa fa-envelope"></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-03-05T07:21:41.000Z" class="post-list__meta--date date">2015-03-05</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/编译/">编译</a>, <a class="tag-link" href="/tags/翻译/">翻译</a>
 </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">将你的iOS 工程转换为支持64位的版本</h1>
  </header>

  <section class="post">
    <p>总的来说，可以根据以下步骤创建一个同时支持32位和64位运行环境的 App:</p>
<ol>
<li>确保 Xcode 版本至少为 5.0.1</li>
<li>打开你的项目，Xcode 提示适配你的工程，编译64位版本的时候可能会给你提出一些重要的警告或者错误。</li>
<li>设置你的项目最低为 iOS 5.1.1, iOS 5.1 之前的系统不支持64位</li>
<li>修改工程的编译指令集为 “Standard Architectures”，即 Xcode 默认版本，其中包括 ARMv7 和 ARM64</li>
<li>更新你的 App 以支持64位运行环境，编译器发出的警告和错误能够引导你处理整个过程，但是 Xcode 不是万能的，你还需要根据本文档来做一些事情。</li>
<li>在 64 位的真机上测试你的 App，模拟器也可以帮助你测试，但是可能有一部分问题只有在真机上才会出现。</li>
<li>使用 Instruments 来分析内存消耗以及性能。</li>
<li>提交支持32位和64位的 App</li>
</ol>
<p>接下来的内容会陈列一些在转换过程中经常出现的问题，根据引导仔细检查你的代码。</p>
<a id="more"></a>
<h2 id="不要将指针转换为整型">不要将指针转换为整型</h2><p>有一些地方可能需要将指针转换为整型数据，但是需要确保接受转换的变量有足够大的位数。</p>
<p>例如，下面 <strong>Listing</strong> 2-1 的代码，将一个指针变量转换为 int 类型，在32位环境下没有问题，因为他们的长度都是4字节，但是在64位环境下会发生截取。</p>
<p><strong>Listing</strong> 2-1 Casting a pointer to int</p>
<pre><code><span class="keyword">int</span> *c = something passed as a argument...
<span class="keyword">int</span> *d = (<span class="keyword">int</span> *)((<span class="keyword">int</span>)c + <span class="number">4</span>);    <span class="comment">// 错误的！</span>
<span class="keyword">int</span> *d = c + <span class="number">1</span>;                    <span class="comment">// 正确</span>

<span class="keyword">int</span> *d = (<span class="keyword">int</span> *)((<span class="keyword">uintptr_t</span>)c + <span class="number">4</span>);    <span class="comment">// 正确</span>
</code></pre><p>如果你必须要将指针转换为整型，可以使用 <code>uintptr_t</code> 类型来避免发生截取。需要注意的是将指针转换为整型做一些运算后又转换为指针违反了一些基本的数据类型规则。处理器使用这个指针去访问的时候可能会导致一个不可预估的行为。</p>
<h2 id="保持数据类型的一致性">保持数据类型的一致性</h2><p>当你在编码的时候，不注意数据类型的一致性时，会发生各种错误或者警告。编译器会提出许多警告，你需要在代码中意识到这些问题。</p>
<p>当调用一个方法的时候，方法接收的参数应该和调用时传入的参数匹配，如果方法返回的数据类型要比接收的变量大，那么就会发生数据截取。 <strong>Listing</strong> 2-2 使用了一个简单的例子来陈述这个问题，<code>PerformCalculation</code> 方法返回了一个 <code>long integer</code> ，在32位环境下，long 和 int 都是32bit，即使这种代码不正确，这种赋值也是不会出错的。但是在64位环境下，赋值的时候，高位的32bit将会被截取。</p>
<p><strong>Listing</strong> 2-2 Truncation when assigning a return value to a variable</p>
<pre><code><span class="function"><span class="keyword">long</span> <span class="title">PerformCalculation</span><span class="params">(<span class="keyword">void</span>)</span></span>;
<span class="keyword">int</span>  x = PerformCalculation(); <span class="comment">// incorrect</span>
<span class="keyword">long</span> y = PerformCalculation(); <span class="comment">// correct!</span>
</code></pre><p>当作为参数传递的时候也有可能出现这种错误，例如 <strong>Listing</strong> 2-3:</p>
<p><strong>Listing</strong> 2-3 Truncation of an input parameter</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">PerformAnotherCalculation</span><span class="params">(<span class="keyword">int</span> input)</span></span>;


<span class="keyword">long</span> i = LONG_MAX;
<span class="keyword">int</span> x = PerformCalculation(i);
</code></pre><p>在 <strong>Listing</strong> 2-4 中，下面的例子也是错误的，因为返回的值的范围超过了方法原型中的返回类型</p>
<p><strong>Listing</strong> 2-4 Truncation when returning a value</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">ReturnMax</span><span class="params">()</span>
</span>{
    <span class="keyword">return</span> LONG_MAX;
}
</code></pre><p>这些例子都是因为代码假定 <code>int</code> 类型和 <code>long</code> 是相同的。ANSI C 标准不认同这种假设，在 64位运行环境下是错误的。默认情况下，你适配了你的工程，那么 <code>-Wshorten-64-to-32</code> 编译器选项是自动开启的，所以当发生数据截断的时候编译器会自动的提示你。如果没有自动适配，那么你需要开启这项，根据需要，你可能想要开启 <code>_Wconversion</code> 选项，它更加详细且能发现更多潜在的问题。</p>
<p>在 Cocoa Touch  框架下开发的 App，查找下面的整型数据类型，确保你是正确的使用它们：</p>
<ul>
<li><p>long</p>
</li>
<li><p>NSInteger</p>
</li>
<li><p>CFIndex</p>
</li>
<li><p>size_t ( <code>sizeof</code> 操作的返回值)</p>
</li>
</ul>
<p>并且在所有的运行环境中， <code>fpos_t</code> 和 <code>off_t</code> 类型都是64位，所以千万不要将它们赋值给 <code>int</code> 类型。 </p>
<h2 id="枚举也是一种类型">枚举也是一种类型</h2><p>在 LLVM 编译器中，枚举类型能够定义枚举变量的大小，这意味着可能一些枚举类型可能比你预期的要大，在这种情况下不要对数据类型的大小做出任何假设，将枚举类型复制给变量时一定要选用适合的数据类型。</p>
<h2 id="Cocoa_Touch_中常见的类型转换问题">Cocoa Touch 中常见的类型转换问题</h2><p>Cocoa Touch,尤其是 Core Foundation 和 Foundation ，你需要额外的关注，因为它们提供了从 C 类型到 Objective-C 的转换。</p>
<p><strong>NSInteger</strong> <strong>changes</strong> <strong>size</strong> <strong>in</strong> <strong>64-bit</strong> <strong>code</strong>.<br><code>NSInteger</code> 类型的使用遍布了整个 Cocoa Touch ，在32位环境中是32bit，在64位环境中增到到了8bit，所以如果从系统的 API 中接收到了 NSInteger 类型的值，也请使用 NSInteger 来保存这个值。</p>
<p>即使你从未假设 <code>NSInteger</code> 和 <code>int</code> 具有相同的大小，下面一些重要的例子你也需要看一下：</p>
<ul>
<li>转换 <code>NSNumber</code> 对象的时候</li>
<li>使用 <code>NSCode</code> 类进行编码和解码的时候，尤其是将 <code>NSInteger</code> 类型在64位设备上编码，又在32位设备上解码的时候，这会造成数据溢出。你应该使用明确的整型变量替换它。</li>
<li>在 Framework 中使用 NSInteger 定义一些常量，比如 <code>NSNotFound</code> 常量,在64位环境中，它的值比 int 类型的最大值还要大，所以截断它的值常常会发生一些错误。</li>
</ul>
<p><strong>CGFloat</strong> <strong>changes</strong> <strong>size</strong> <strong>in</strong> <strong>64-bit</strong> <strong>code</strong>:</p>
<p><code>CGFloat</code> 在64位环境中是 8bit，你不能假定 <code>CGFloat</code> 等同于 <code>float</code> 或者 <code>double</code>,所以始终使用 CGFloat 吧。<br><strong>Listing</strong> 2-5 举了一个使用 Core Foundation 创建 CFNumber 的例子，但是代码错误的假定了 CGFloat 和 float 具有相同的大小。</p>
<p><strong>Listing</strong> 2-5 Use CGFloat types consistently</p>
<pre><code><span class="comment">// 错误！</span>
<span class="built_in">CGFloat</span> value = <span class="number">200.0</span>;
<span class="built_in">CFNumberCreate</span>(k<span class="built_in">CFAllocatorDefault</span>, k<span class="built_in">CFNumberFloatType</span>, &amp;value);


<span class="comment">// 正确～</span>
<span class="built_in">CGFloat</span> value = <span class="number">200.0</span>;
<span class="built_in">CFNumberCreate</span>(k<span class="built_in">CFAllocatorDefault</span>, k<span class="built_in">CFNumberCGFloatType</span>, &amp;value);
</code></pre><h2 id="注意整型计算">注意整型计算</h2><p>尽管数据被截取是一个常见的情况，但也可能碰到其他与整型有关的问题。下面的指南会引导你修改你的代码。</p>
<h3 id="C_语言和基于_C_语言的其他语言的符号位拓展规则">C 语言和基于 C 语言的其他语言的符号位拓展规则</h3><p>C 语言和其他一些类似的语言，使用了一套赋值扩展规则，用来决定当整型的值转换为位数比较大的变量时,符号位的拓展规则。</p>
<ol>
<li>当从一个小值扩展到大值时，无符号的值用 0 扩展。</li>
<li>有符号的值扩展时，符号位跟着扩展</li>
<li>常量(除非带后缀，例如 0x8L) 按照最小位数来对待，Nsnumber 对象被编译器认为是有符号或者无符号的 int、long、long long。小数一致被当作有符号类型。</li>
<li>一个具有符号位的值和相同位数无符号值的和仍是无符号的。</li>
</ol>
<p>请看下面的例子：</p>
<pre><code><span class="keyword">int</span> a = -<span class="number">2</span>;
<span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">1</span>;
<span class="keyword">long</span> c = a + b;
<span class="keyword">long</span> <span class="keyword">long</span> d = c;

<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,d); 
</code></pre><p><code>问题</code>： 当运行在 32 位系统上时，结果是 －1 （0xFFFF FFFF）64位上为 4294967295（0x0000 0000 FFFF FFFF）</p>
<p><code>原因</code>：有符号值与无符号的值相加，是一个无符号的数，当被赋值给一个更大的数时，导致符号位没有拓展</p>
<p><code>解决办法</code>：在32位上，使 b 转换为 long 类型，这样子使得 b 扩展到 64 位。</p>
<p>下面是另一个与之有关的错误例子：</p>
<pre><code><span class="keyword">unsigned</span> <span class="keyword">short</span> a=<span class="number">1</span>;
<span class="keyword">unsigned</span> <span class="keyword">long</span> b = (a &lt;&lt; <span class="number">31</span>);
<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> c=b;
<span class="built_in">printf</span>(<span class="string">"%llx\n"</span>, c);
</code></pre><p><code>问题</code>： 当运行在 32 位系统上时，结果是 0x8000 0000，但是在64位上为 0xFFFF FFFF 8000 0000</p>
<p><code>原因</code>：为什么符号位做了扩展？首先，当左位移操作被调用时，a 变量扩展到 int 类型，因为所有 short 类型的数值，都能正常转换为有符号的 int，这样值就是有符号的了。</p>
<p>第二步，当左移操作完成时，这个值存储到 long 类型，在 32位 中，long 和 int 是匹配的，所以不会有问题，但是在 64位 上，会做有符号位的扩展。</p>
<p><code>解决办法</code>：在左移前，转换 a 为 long 类型。    </p>
<h3 id="位和位掩码">位和位掩码</h3><p>在 64位的值中使用位和掩码时，你需要避免不小心带入 32位的值，下面是一些提示：</p>
<p><code>不要认为数据类型拥有固定的长度</code> 如果你转换一个存储在 long integer 类型中的 bits 来转移，那么使用 LONG_BIT 值来指明 long integer 中有多少位。超过了变量的长度之后的转换结果与体系结构有关系。</p>
<p><code>在必要的时候使用倒掩码</code> 在对 long 类型使用位掩码的时候需要特别小心，因为它在32位下和64位下是不同的，下面有两种创建掩码的方式，取决于你是使用零位扩展还是符号位扩展。</p>
<ol>
<li><p>If you want the mask value to contain zeros in the upper 32 bits in the 64-bit runtime, the usual fixed-width mask works as expected, because it will be extended in an unsigned fashion to a 64-bit quantity.</p>
</li>
<li><p>If you want the mask value to contain ones in the upper bits, write the mask as the bitwise inverse of its inverse,如下所示.</p>
</li>
</ol>
<p>Using an inverted mask for sign extension:</p>
<pre><code>function_name(<span class="keyword">long</span> <span class="keyword">value</span>)
{
    <span class="keyword">long</span> mask = ~<span class="number">0x3</span>; <span class="comment">// 0xfffffffc or 0xfffffffffffffffc</span>
    <span class="keyword">return</span> (<span class="keyword">value</span> &amp; mask);
}
</code></pre><h2 id="创建数据结构时使用固定的大小和对齐方式">创建数据结构时使用固定的大小和对齐方式</h2><p>当数据被同时用于 32位 和 64位下时，需要使得它们的表现相同，还需要注意的是，用户有可能在 32位环境下存入数据，在64位环境上使用数据。</p>
<h3 id="使用明确的整型数据">使用明确的整型数据</h3><p>C99 标准提供了内建的数据类型保证了其大小的固定，    而不用理会底层的硬件和体系结构。你需要使用这些数据类型。同时也需要注意避免内存浪费。</p>
<p>下面是 C99 的标准</p>
<table><br> <tr><br>  <td>Type</td><br>  <td>Range</td><br> </tr><br> <tr><br>  <td>int8_t </td><br>  <td>-128 to 127</td><br> </tr><br> <tr><br>  <td>int16_t</td><br>  <td> -32,768 to 32,767</td><br> </tr><br> <tr><br>  <td>int32_t</td><br>  <td> -2,147,483,648 to 2,147,483,647</td><br> </tr><br> <tr><br>  <td>int64_t</td><br>  <td> -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td><br> </tr><br> <tr><br>  <td>uint8_t </td><br>  <td>0 to 255</td><br> </tr><br> <tr><br>  <td>uint16_t</td><br>  <td> 0 to 65,535</td><br> </tr><br> <tr><br>  <td>uint32_t</td><br>  <td> 0 to 4,294,967,295 </td><br> </tr><br> <tr><br>  <td>uint64_t</td><br>  <td> 0 to 18,446,744,073,709,551,615</td><br> </tr><br></table>


<h2 id="注意_64位的对齐方式">注意 64位的对齐方式</h2><p>在64位运行环境中，字节对齐从 4 bit 增加到了 8bit，即使你明确指定了每个类型的长度，但是在不同的运行环境中仍然可能不同。</p>
<p>Alignment of 64-bit integers in structures</p>
<pre><code>struct bar {
    i<span class="label">nt32</span>_t fo<span class="preprocessor">o0</span>;
    i<span class="label">nt32</span>_t fo<span class="preprocessor">o1</span>;
    i<span class="label">nt32</span>_t fo<span class="preprocessor">o2</span>;
    i<span class="label">nt64</span>_t bar;
};
</code></pre><p>当这段代码在 32位环境下编译时，bar 的结构是从一开始的 12 个字节，在 64位下，是从一开始的 16 个字节，这是由于不同的字节对齐导致的。</p>
<p>32位下：</p>
<pre><code>foo0 <span class="number">4</span>字节 <span class="number">0x0000</span> <span class="number">0000</span> 开始
foo1 <span class="number">4</span>字节 <span class="number">0x0000</span> <span class="number">0004</span> 开始
foo2 <span class="number">4</span>字节 <span class="number">0x0000</span> <span class="number">0008</span> 开始
bar  <span class="number">8</span>字节 <span class="number">0x0000</span> <span class="number">0012</span> 开始
</code></pre><p>64位下：</p>
<pre><code>foo0 <span class="number">4</span>字节 <span class="number">0x0000</span> <span class="number">0000</span> 开始
foo1 <span class="number">4</span>字节 <span class="number">0x0000</span> <span class="number">0004</span> 开始
foo2 <span class="number">4</span>字节 <span class="number">0x0000</span> <span class="number">0008</span> 开始
bar  <span class="number">8</span>字节 <span class="number">0x0000</span> <span class="number">0016</span> 开始 <span class="comment">// 需要在之前填充 4 个字节</span>
</code></pre><p>如果需要重新定义一个结构体，使得对齐字节比较大的的元素在前面，比较小的在后面，这样子会减少填充字节。如果为了向后兼容，可以使用程序强制 32位 下的对齐，如下：</p>
<p>Listing 2-10 Using pragmas to control alignment</p>
<pre><code><span class="preprocessor">#<span class="keyword">pragma</span> pack(<span class="number">4</span>)</span>
<span class="keyword">struct</span> bar {
    <span class="keyword">int32_t</span> foo0;
    <span class="keyword">int32_t</span> foo1;
    <span class="keyword">int32_t</span> foo2;
    <span class="keyword">int64_t</span> bar;
};
<span class="preprocessor">#<span class="keyword">pragma</span> options align=reset</span>
</code></pre><p>上面的做法是实在没办法才去使用的，因为这样子会有性能上面的损失。</p>
<h2 id="使用_sizeof_分配内存空间">使用 sizeof 分配内存空间</h2><p>永远不要使用固定的数字作为 Malloc 的参数，应该使用 sizeof。因为你无法确定到底是多大。</p>
<h2 id="修改格式化字符串来支持不同的平台">修改格式化字符串来支持不同的平台</h2><p>为了解决不同平台下的问题，可以使用 pointer-sized 整型（uintptr_t）或其他一些标准类型，都定义在 inttypes.h 头文件中。</p>
<p>#####Standard format strings</p>
<table><br>    <tr><br>        <td>Type</td><br>        <td>Format string</td><br>    </tr><br>    <tr><br>        <td>int</td><br>        <td>%d</td><br>    </tr><br>    <tr><br>        <td>long</td><br>        <td>%ld</td><br>    </tr><br>    <tr><br>        <td>long long</td><br>        <td>%lld</td><br>    </tr><br>    <tr><br>        <td>size_t</td><br>        <td>%zu</td><br>    </tr><br>    <tr><br>        <td>ptrdiff_t</td><br>        <td>%td</td><br>    </tr><br>    <tr><br>        <td>any pointer</td><br>        <td>%p</td><br>    </tr><br><table><br><br><br>#####Additional inttypes.h format strings (where N is some number)<br><br><table><br> <tr><br>  <td>Type</td><br>  <td>Format string</td><br> </tr><br> <tr><br>  <td>int[N]_t (such as int32_t)</td><br>  <td>PRId[N] (such as PRId32</td><br> </tr><br> <tr><br>  <td>uint[N]_t</td><br>  <td>PRIu[N]</td><br> </tr><br> <tr><br>  <td>int_least[N]_t</td><br>  <td>PRIdLEAST[N]</td><br> </tr><br> <tr><br>  <td>uint_least[N]_t</td><br>  <td>PRIuLEAST[N]</td><br> </tr><br> <tr><br>  <td>int_fast[N]_t</td><br>  <td>PRIdFAST[N]</td><br> </tr><br> <tr><br>  <td>uint_fast[N]_t</td><br>  <td>PRIuFAST[N]</td><br> </tr><br> <tr><br>  <td>intptr_t</td><br>  <td>PRIdPTR</td><br> </tr><br> <tr><br>  <td>uintptr_t</td><br>  <td>PRIuPTR</td><br> </tr><br> <tr><br>  <td>intmax_t</td><br>  <td>PRIdMAX</td><br> </tr><br> <tr><br>  <td>uintmax_t</td><br>  <td>PRIuMAX</td><br> </tr><br></table>

<p>例如需要打印一个 <code>intptr_t</code> 的变量，如下</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span>
<span class="keyword">void</span> *foo;
<span class="keyword">intptr_t</span> k = (<span class="keyword">intptr_t</span>) foo;
<span class="keyword">void</span> *ptr = &amp;k;
<span class="built_in">printf</span>(<span class="string">"The value of k is %"</span> PRIdPTR <span class="string">"\n"</span>, k);
<span class="built_in">printf</span>(<span class="string">"The value of ptr is %p\n"</span>, ptr);
</code></pre><p>##注意函数和函数指针</p>
<p>函数调用在 32 位和 64位的处理上是不一致的，关键在于在调用固定参数方法和可变参数方法使用不同的指令读取参数。下面展示了两种不同的方法原型，第一个方法 <code>fixedFunction</code> 总是使用一对整数。第二个方法使用至少两个的可变参数，在32位下，方法调用的指令时相同的，但是在 64位下是不同的，因为使用了一些转换。</p>
<p>64-bit calling conventions vary by function type</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">fixedFunction</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;
<span class="function"><span class="keyword">int</span> <span class="title">variadicFunction</span><span class="params">(<span class="keyword">int</span> a, ...)</span></span>;
<span class="keyword">int</span> main {
    <span class="keyword">int</span> value2 = fixedFunction(<span class="number">5</span>,<span class="number">5</span>);
    <span class="keyword">int</span> value1 = variadicFunction(<span class="number">5</span>,<span class="number">5</span>);
}
</code></pre><p>在64位下的调用约定变的更加精确，所以要确保你调用是正确的。并且调用者总能找到被调用的方法。</p>
<h3 id="一定要定义方法原型">一定要定义方法原型</h3><p>在使用最新的工程配置来编译的时候，如果你企图调用不太明确的方法，编译器会提示一些错误。你必须要提供一个方法原型，这样编译器才知道它是可变的方法或者别的。</p>
<h3 id="方法指针必须使用正确的类型">方法指针必须使用正确的类型</h3><p>如果在代码中传递方法指针，那么它的调用约定必须是保持一致的。必须要保持同样的方法参数。不要将可变方法转换为不可变方法。下面的例子就是一个错误的方法调用，因为方法调用使用了不同的调用规则，调用者传入的参数并不是方法所希望的。</p>
<p>Casting between variadic and nonvariadic functions results in an error</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">MyFunction</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, ...)</span></span>;
<span class="keyword">int</span> (*action)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>) = (<span class="keyword">int</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)) MyFunction;
action(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// Error!</span>
</code></pre><blockquote>
<p>如果你在自己的代码中使用到了如上的方法转换，编译器可能不会给你警告或者错误，在模拟器上测试可能也不会出现问题，所以一定要在真机上进行测试。</p>
</blockquote>
<h3 id="使用方法原型进行消息分发">使用方法原型进行消息分发</h3><p>转换规则有一个特例如标题描述，就是在使用 <code>objc_msgSend</code> 方法或者 OBJC 运行时其他的一些消息传递方法。尽管这些方法是可变参数的形式，但是 Objc 运行时的消息传递调用这些方法时不会共享相同的原型。Objc Runtime 直接调用到这些方法的具体实现，所以就如之前所说，这些调用规则是不适用的。所以需要在调用之前转换 <code>objc_msgSend</code> 方法为一个原型匹配的方法。</p>
<p>下面的例子展示了如何使用底层的消息调用分发消息到另一个对象。在这个例子中，<code>doSomething:</code> 方法使用了单个参数，不是可变参数。需要注意的是 method function 总是使用 id、SEL 作为前两个参数。当 <code>objc_msgSend</code> 转换为函数指针后，调用会经过相同的函数指针。</p>
<p>Using a cast to call the Objective-C message sending functions</p>
<pre><code>(<span class="keyword">int</span>) doSomething:(<span class="keyword">int</span>) x { ... }
- (<span class="keyword">void</span>) doSomethingElse {
    <span class="keyword">int</span> (*action)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>) = (<span class="keyword">int</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>)) objc_msgSend;
    action(<span class="keyword">self</span>, <span class="keyword">@selector</span>(doSomething:), <span class="number">0</span>);
}
</code></pre><h3 id="调用可变参数的方法时需要特别小心">调用可变参数的方法时需要特别小心</h3><p>可变参数列表 (<code>varargs</code>) 不会提供参数的类型信息，而且不会自动提升到大的类型。如果你需要区分传入数据的类型，你有望使用格式化的字符串或者其他类似的机制来提供 <code>varargs</code> 方法的信息。如果调用的方法没有提供正确的信息，你可能得到错误的结果。</p>
<p>尤其是你的 <code>varargs</code> 方法希望一个 long integer 而你传入了一个 32bit 的值，那么很有可能方法接受了这个32bit 的值，又从下一个参数中读取了 32bit 的垃圾。同样的，如果方法希望传入 long ，而你传入了 int ，也会造成错误。</p>
<h3 id="千万不要直接保存_Objective-C_指针">千万不要直接保存 Objective-C 指针</h3><p>如果你的代码直接保存对象的 isa 字段，那么在64位环境下出错。isa 字段不再保存一个指针。做为替代，它保存了指针以及其他一些运行时的信息。这种优化提高了内存使用率以及性能。</p>
<p>使用 <code>class</code> 原型或着调用 <code>object_getClass</code> 读取 isa 字段。使用 <code>objec_setClass</code> 写入。</p>
<p>这些问题也不会出现在模拟器中，需要在真机中测试。</p>
<h3 id="使用内置的同步原语">使用内置的同步原语</h3><p>有的时候，App 为了提高性能实现了自己的同步原语。iOS Runtime 环境提供了一整套的原语，并且对于每一种 CPU 做了优化。Runtime 文档也做了更新，总之，还是使用内置的原语吧。</p>
<h3 id="不要硬编码改变虚拟内存页面的大小">不要硬编码改变虚拟内存页面的大小</h3><p>通常是不需要知道页面大小的，如果是为了做缓存分配或者其他动态库调用，使用 <code>getpagesize( )</code>来获取。</p>
<h3 id="使用位置无关代码">使用位置无关代码</h3><p>64位环境仅仅支持 <code>独立位置的可执行区域 PIE</code> , 默认情况下 App 的编译都是使用位置无关，如果你有一些代码使得你无法使用位置无关，比如一些静态链接库或者汇编代码，那么你需要改变它。</p>
<h3 id="在_32_位环境下也要_Run_Well">在 32 位环境下也要 Run Well</h3><p>当前，支持64位环境的 App 也是支持 32 位的，最好就是一份设计支持两种环境，当然偶尔需要分别对待。</p>
<p>举个🌰，你可能为了方便在整个代码中使用 64bit 整型，两种环境都支持 64bit 整型，并且能够简化你 App 的设计，但是在 32bit 环境下可能会慢一些。如果你的计算在32位下是足够的，那么还是使用 32bit。</p>
<h1 id="优化内存性能">优化内存性能</h1><p>由于 64位 编译器的支持，64位的 App 能够运行的更快一些，但是同样，占用的内存也会大一些，为了减少内存压力，你需要对你的 App 做一些内存方面的优化。</p>
<h2 id="剖析你的_App">剖析你的 App</h2><p>在对你的 App 进行内存优化之前，你首先需要创建一些标准测试同时跑在 32bit 和 64bit 的环境下，来量化内存性能的损耗，以及量化你的优化结果。至少需要一个轻量化的测试用例，以及很多复杂的测试用例。这些测试的目标是量化内存消耗的具体位置。</p>
<h2 id="常见的内存使用问题">常见的内存使用问题</h2><p>下面是一些常见的内容使用问题以及解决办法。</p>
<h3 id="Foundation_的对象对于小的载体可能太过">Foundation 的对象对于小的载体可能太过</h3><p>许多 Foundation 框架下的类提供了一个灵活的集合，灵活性跟其他简单的数据结构相比较消耗了比较大的内存，举个🌰，使用 <code>NSDictionary</code> 对象来保存简单的 <code>key－value</code> 键值对就比简单的变量保存要消耗更多的内存。如果是大量这样的 NSDictionary 对象，那么就会占用更大的内存，尤其是在 64 位下。所以这种对象需要适合的使用。</p>
<h3 id="使用紧凑的数据描述">使用紧凑的数据描述</h3><p>在定义数据结构的时候，不同的顺序会有不同的大小，这跟字节对齐有关系。</p>
<pre><code>struct date {
    NSInteger second<span class="comment">;</span>
    NSInteger minute<span class="comment">;</span>
    NSInteger hour<span class="comment">;</span>
    NSInteger day<span class="comment">;</span>
    NSInteger month<span class="comment">;</span>
    NSInteger year<span class="comment">;</span>
}<span class="comment">;</span>
</code></pre><p>上面的结构体在32位下 24个字节，64下 48字节。改为下面的结构就简单多了</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">date</span> </span>{
    time_t seconds;
};
</code></pre><p>需要注意的是， <code>time_t</code> 数据类型在 32bit 和 64bit 下的大小是不一样的。</p>
<h3 id="整理结构体">整理结构体</h3><p>为了数据对齐，编译器会增加一些空内存。例如：</p>
<pre><code><span class="keyword">struct</span> bad {
    <span class="keyword">char</span>       a;    <span class="comment">// offset 0 </span>
    <span class="keyword">int32_t</span>    b;    <span class="comment">// offset 4</span>
    <span class="keyword">char</span>       c;    <span class="comment">// offset 8</span>
    <span class="keyword">int64_t</span>    d;    <span class="comment">// offset 16</span>
};    
</code></pre><p>这个结构体只有 14字节的数据，但是由于空内存块提升到了 24字节</p>
<p>下面是一个比较好的例子：</p>
<pre><code><span class="keyword">struct</span> good {
    <span class="keyword">int64_t</span>    d;    <span class="comment">// offset 0</span>
    <span class="keyword">int32_t</span>    b;    <span class="comment">// offset 8</span>
    <span class="keyword">char</span>       a;    <span class="comment">// offset 12;</span>
    <span class="keyword">char</span>       c;    <span class="comment">// offset 13;</span>
};
</code></pre><h3 id="少用指针">少用指针</h3><p>避免滥用指针，思考下面的实现：</p>
<pre><code>struct <span class="keyword">node</span><span class="identifier"> </span><span class="title">{
    node</span>        *previous;
    <span class="keyword">node</span><span class="identifier">        </span><span class="title">*next</span>;
    uint32_t    value;
};    
</code></pre><p>32位编译下，12个字节中只有 4字节用作有效数据，在64位下，有效数据占用了 20%，所以思考用数组或者其他方式来实现吧    </p>
<h3 id="字节对齐导致的内存分配">字节对齐导致的内存分配</h3><p>当你直接调用 malloc 方法的时候（例如 objctive-C 对象 alloc 的时候），操作系统会额外申请一些内存空间来维持字节对齐。当初始化 C 结构体的时候，申请几个大的内存块比为每一个结构体单独申请要有效率的多。</p>
<h3 id="只有在需要的时候才去缓存">只有在需要的时候才去缓存</h3><p>缓存之前的数据或者计算结果是一种常见的提高性能的方式。当然，你仍然需要查看缓存是否真正的提高了你 App 的效率。如之前所说，64位下的内存消耗要比32位大的多，如果你的 App 依赖于太多的缓存策略，过多的使用虚拟缓存可能反而会降低性能。</p>
<p>避免以下典型的错误例子:</p>
<ul>
<li>缓存一些类能够快速创建的数据</li>
<li>缓存一些能够快速从其他对象获取到的对象或者数据</li>
<li>缓存系统可以快速创建的对象</li>
<li>缓存一些能够快速映射到内存的只读数据</li>
</ul>
<p>一定要通过测试确保缓存提高了 App 的性能，使用钩子来可以选择性的开启某些缓存策略，使用不同的数据集合来验证你的缓存算法。</p>
<blockquote>
<p>更新时间： 2014-02-11</p>
</blockquote>
</table></table>
  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/03/09/2015-03-09-ios-bing-fa-bian-cheng-zhi-nan-1/" title="iOS 并发编程指南(一)">iOS 并发编程指南(一)</a></h2>
                <p class="excerpt">
                
                
本文为翻译苹果官方文档，旨在自我学习，翻译之处会有坑，请酌情参考

简介并发是指多件事情同时发生。随着多核 CPU 的实现，每个处理器上的核心只会增加，开发人员需要新的方式来充分利用它们。尽管像 OS X 和 iOS 这样的操作系统（自卖自夸，别的 OS 被你吃了吗？）能够并行的运行多个程序，其中大多数的程序运行在后台，并且经常需要一小段 CPU 时间来执行任务。运行在前台的程序与用户交互并且占用大量的 CPU 时间。如果一个程序有很多任务去做但是只有一部分内核可以使用，那么额外的计算资源将被浪费。
在过去，在程序中引入并发需要创建额外的一个或多个线程。不幸的是，写线程级别的代码很具有挑战性。线程是很底层的工具，必须手动来管理。对于一个程序，由于线程的最佳数目基于系统负载和底层硬件动态改变，实现一个正确的线程解决方案是非常困难的。此外，线程的同步机制通常会给软件设计增加复杂性和带来风险，并不能保证一定会提高程序性能。
相比较传统的基于线程的系统和应用程序，OS X 和 iOS 更多地采用异步方法来执行并行的任务。应用程序只需要定义特定的任务，然后让系统执行它们，而不是直接创建线程。通过让操作系统来管理线程，使得应用程序具有了原生线程不可能带来的可扩展性。开发者也有了更加简单高效的编程模式。
本文档描述了并发编程的技术和技巧，使用与 OS X 和 iOS。
文档包含以下章节：

并行和程序设计：介绍了基本的异步程序设计和异步执行自定义任务的技巧
Operation Queues（操作队列）：指出如何使用 Objective-C 对象封装任务并且执行
Dispatch Queue（分发队列）：如何并行的执行任务在 C 语言编程中
Dispatch Sources：如何异步的处理系统时间
Migrating Away from Threads：介绍如何将已存在的基于线程的代码迁移至新的技术上。

                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-03-09T07:38:28.000Z" class="post-list__meta--date date">2015-03-09</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/GCD/">GCD</a>, <a class="tag-link" href="/tags/并发编程/">并发编程</a>, <a class="tag-link" href="/tags/翻译/">翻译</a>
</span><a class="btn-border-small" href="/2015/03/09/2015-03-09-ios-bing-fa-bian-cheng-zhi-nan-1/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/03/02/2015-03-02-64-bit-transition-guide-for-cocoa-touch-yi-wen-,ru-he-rang-ni-de-app-zhi-chi-64wei/" title="64-Bit Transition Guide for Cocoa Touch 译文，如何让你的App 支持64位">64-Bit Transition Guide for Cocoa Touch 译文，如何让你的App 支持64位</a></h2>
                <p class="excerpt">
                
                Apple 为了让搭载64位处理器的 iOS 设备性能得到发挥，下了最后通牒：

As we announced in October, beginning February 1, 2015 new iOS apps submitted to the App Store must include 64-bit support and be built with the iOS 8 SDK. Beginning June 1, 2015 app updates will also need to follow the same requirements.


从 2015 年 2 月 1 日开始，所有新提交的 App 必须支持64位，并且使用 iOS8 SDK 编译，从 2015 年 6 月 1 日开始，更新版本的 App 也需要这样做。

                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-03-02T10:10:26.000Z" class="post-list__meta--date date">2015-03-02</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/翻译/">翻译</a>
</span><a class="btn-border-small" href="/2015/03/02/2015-03-02-64-bit-transition-guide-for-cocoa-touch-yi-wen-,ru-he-rang-ni-de-app-zhi-chi-64wei/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 Well Cheng - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
