<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>AutoLayout 读书笔记(二) | Charvel 互联网自留地</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="约束AutoLayout 是一种约束满足系统，约束的本质就是限制,布局中，创建的每一个规则都提出一个要求，这些要求规定了视图中一个部分与另一个部分之间的关系，这些规定具有优先级，AutoLayout 系统根据所有的规则，确定唯一的布局方式。">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="AutoLayout 读书笔记(二) | Charvel 互联网自留地">
    <meta name="twitter:description" content="约束AutoLayout 是一种约束满足系统，约束的本质就是限制,布局中，创建的每一个规则都提出一个要求，这些要求规定了视图中一个部分与另一个部分之间的关系，这些规定具有优先级，AutoLayout 系统根据所有的规则，确定唯一的布局方式。">

    <meta property="og:type" content="article">
    <meta property="og:title" content="AutoLayout 读书笔记(二) | Charvel 互联网自留地">
    <meta property="og:description" content="约束AutoLayout 是一种约束满足系统，约束的本质就是限制,布局中，创建的每一个规则都提出一个要求，这些要求规定了视图中一个部分与另一个部分之间的关系，这些规定具有优先级，AutoLayout 系统根据所有的规则，确定唯一的布局方式。">

    
    <meta name="author" content="Well Cheng">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Charvel 互联网自留地" href="/atom.xml">
    

    <link rel="canonical" href="http://blog.devcheng.com/2015/04/23/2015-04-23-autolayout-du-shu-bi-ji-er/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Charvel 互联网自留地 的主页"><img src="/images/avatar.jpg" width="80" alt="Charvel 互联网自留地 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Charvel 互联网自留地">Charvel 互联网自留地</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">记录生活的点点滴滴，记录技术的淅淅沥沥</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/favourite">黄金屋</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/monniya" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/onlymonniya" title="Twitter" target="_blank">
      <i class="social fa fa-twitter"></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:chengwei3269@hotmail.com" title="Mail" target="_blank">
      <i class="social fa fa-envelope"></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-04-23T01:00:52.000Z" class="post-list__meta--date date">2015-04-23</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/AutoLayout/">AutoLayout</a>, <a class="tag-link" href="/tags/学习笔记/">学习笔记</a>
 </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">AutoLayout 读书笔记(二)</h1>
  </header>

  <section class="post">
    <h2 id="约束">约束</h2><p>AutoLayout 是一种约束满足系统，约束的本质就是<code>限制</code>,布局中，创建的每一个规则都提出一个要求，这些要求规定了视图中一个部分与另一个部分之间的关系，这些规定具有优先级，AutoLayout 系统根据所有的规则，确定唯一的布局方式。</p>
<a id="more"></a>
<h3 id="约束类型">约束类型</h3><p>AutoLayout 的核心约束类</p>
<ul>
<li><p>布局约束（NSLayoutConstraint 类，Public）<br>布局约束规则用来指定视图的几何特征，这些规则将视图与其他视图关联起来确定视图的位置和尺寸，要么直接指定其位置和尺寸为一个常数。</p>
</li>
<li><p>内容大小约束（NSContentSizeLayoutConstraint，Private）<br>内容大小规则，指定其视图尺寸与内容之间的关系，例如，内容吸附规则尽量避免添加补白，内容压缩规则阻止视图被剪裁。</p>
</li>
<li><p>自动尺寸调整约束 （NSAutoresizingMaskLayoutConstraint，Private）<br>自动尺寸调整约束，将原来的 Autoresizing 转换为 AutoLayout 系统中对应的约束。</p>
</li>
<li><p>布局支持系统 （ _UILayoutSupportConstraint，Private）<br>布局支持约束，是 iOS 7 中新增的约束，用来建立视图控制器实例顶部和底部的实际边界，它防止视图的内容与类似 statusBar 之类的障碍物发生重叠</p>
</li>
<li><p>原型约束（NSIBProtypingLayoutConstraint，Private）<br>iOS7 新增，它是 IB 为你添加的约束，在迭代构造界面的过程中，仍然保留一个用于测试的工作界面，在发布应用时，不能引用原型约束。</p>
</li>
</ul>
<p>在开发和调试 AutoLayout 时，Xcode 调试信息会显示出这些类的实例。</p>
<p>不管是什么类，所有约束类型：</p>
<ol>
<li>表达视图在屏幕上的布局方式</li>
<li>都有一个内在的优先级，指定每个请求在 AutoLayout 系统中的强烈程度。</li>
</ol>
<h3 id="优先级">优先级</h3><p>优先级表示规则请求强烈程度的数字，AutoLayout 使用优先级解决某些约束冲突。范围：<code>1~1000</code>，数字越大，优先级越高。</p>
<p>iOS UIKit 提供了常用的优先级枚举值：</p>
<pre><code><span class="class"><span class="keyword">enum</span> {</span>
    <span class="constant">UILayoutPriorityRequired</span> = <span class="number">1000</span>,    <span class="regexp">//</span> 必须满足
    <span class="constant">UILayoutPriorityDefaulthigh</span> = <span class="number">750</span>,    <span class="regexp">//</span> 压缩抵抗的默认优先级
    <span class="constant">UILayoutPriorityDefaultLow</span> = <span class="number">500</span>,    <span class="regexp">//</span> 
    <span class="constant">UILayoutPriorityFittingSizeLevel</span> = <span class="number">50</span>,    <span class="regexp">//</span> 
}
</code></pre><p>一般建议创建自己的优先级约束枚举类型。</p>
<h3 id="内容大小约束">内容大小约束</h3><p>iOS 中，每一个 View 都是由其在父视图中的位置 position 和尺寸 size 来确定其位置的。虽然我们之前经常会指定其大小，但是现在在多屏幕尺寸的开发中，更迫切的希望能够跟随内容动态的调整其位置和大小。</p>
<p>之前提过，label、imageView 和 其他 UIControl 的大小取决于其需要呈现的内容。<br>而不包含自然内容的视图，其内在内容大小为（-1，-1），UIKit 将这种无内容的尺寸声明为 UIViewNoIntrinsicMetric。Apple 指出：</p>
<blockquote>
<p>并非所有的视图都有 intrinsicContentSize。UIView 的默认实现是返回 （intrinsicContentSize，intrinsicContentSize）。内在内容大小仅考虑视图自身中的数据，而不考虑其他视图中的数据。<br>记住，仍然可以针对任何视图设置其高度、宽度约束。如果不希望这些尺寸随内容而改变，那么你不需要重写 instrinsicContentSize。</p>
</blockquote>
<p>内容吸附约束限制视图允许自身伸展和填充视图的程度。如果这个优先级比较高，那么视图的 frame 将与自身内容相匹配。</p>
<p>压缩阻力防止视图剪切其内容。高优先级可以确保视图显示出完整的内在内容。</p>
<p>可以通过代码为每一个视图指定内容吸附和压缩阻力优先级。<br>内容吸附优先级为 250（所以指定尺寸时，内容吸附会被忽略）。压缩阻力优先级默认为 750：</p>
<pre><code><span class="pp">- <span class="params">(void)</span>setContentHuggingPriority:<span class="params">(<span class="variable">UILayoutPriority</span>)</span>priority forAxis:<span class="params">(<span class="variable">UILayoutConstraintAxis</span>)</span>axis
- <span class="params">(<span class="variable">UILayoutPriority</span>)</span>contentHuggingPriorityForAxis: <span class="params">(<span class="variable">UILayoutConstraintAxis</span>)</span>axis
- <span class="params">(void)</span>setContentCompressionResistancePriority:<span class="params">(<span class="variable">UILayoutPriority</span>)</span>priority forAxis:<span class="params">(<span class="variable">UILayoutConstraintAxis</span>)</span>axis
- <span class="params">(<span class="variable">UILayoutPriority</span>)</span>contentCompressionResistancePriorityForAxis: <span class="params">(<span class="variable">UILayoutConstraintAxis</span>)</span>axis</span>
</code></pre><p>当然也可以通过 IB 设置内容大小约束。</p>
<h3 id="构建布局约束">构建布局约束</h3><p>布局约束（NSLayoutConstraint 的实例）定义了视图的物理几何特征的规则，指定了视图的布局方式，以及视图与同一层级结构中其他视图的关系。</p>
<p><img src="http://7vzucb.com1.z0.glb.clouddn.com/blog.AutoLayout-elements.png" alt="自动布局约束元素表"></p>
<h3 id="布局约束类">布局约束类</h3><p>数学规则通过构建 NSLayoutConstraint 类的实例构建，然后将创建的规则应用到视图中，该类的实例提供以下几个基本约束：</p>
<ul>
<li>priority：优先级</li>
<li>firstItem 与 secondItem ，约束关联的视图</li>
<li>firstAttribute 与 secondAttribute ：约束系统中的名词，描述视图对齐矩阵的特征，如左边、右边、中心、高度，为上表中 12 个枚举类型中的任意一个，不存在第二项，使用 NSLayoutAttributeNotAnAttribute 占位符</li>
<li>relation：动词。指出属性之间如何比较</li>
<li>mutiplier 和 constant：提供代数元素，增强约束的功能和灵活性，通过这个属性，可以指出一个视图是另一个视图的一半，也可以指定一个视图是通过另一个视图偏移某个距离得到的。</li>
</ul>
<p>约束本质山就是数学中的相等或者不等关系，用公式表示就是：</p>
<pre><code>y （关系）m <span class="keyword">*</span> x + b
</code></pre><p>例如，视图 B 的左边 = 视图 A 的右边 + 15，这个是相等关系</p>
<p>或者，视图 B 的左边 &gt;= 视图 A 的右边 + 15，这个是不等关系</p>
<p>其中 m 是缩放因子，用来方法缩小视图，b 是偏移常数</p>
<p>一般来说，构建的关系式都涉及两个视图，即</p>
<pre><code><span class="tag">firstItem</span><span class="class">.firstAttribute</span> (<span class="tag">R</span>) <span class="tag">secondItemAttribute</span> * <span class="tag">m</span> + <span class="tag">b</span>
</code></pre><p>firstItem 和 secondItem 的顺序可以任意，也可以表示为 [视图A]-10-[视图B]，从理解上来讲，应该是视图 B 右边距离视图 A 的右边 10pt，因为我们总是将左上的视图作为 firstItem，将右下的视图作为secondItem。</p>
<h3 id="创建布局约束">创建布局约束</h3><p>构建布局约束有 3 种方法：</p>
<ul>
<li>IB 设计界面</li>
<li>可视化约束语言 ，允许 NSLayoutConstraint 根据请求生成实例</li>
<li>为每一个组件提供一个基本关系，从而构建 NSLayoutConstraint 的实例</li>
</ul>
<p>从简易程度上讲，是从上到下的，并且从上到下也是 Apple 推荐的顺序，但是作为开发者，我认为还是从下往上比较好，因为在 IB 中创建约束后，你过后经常会忘记你当时想要的是什么布局，而且对于边界条件不能够很好的处理。</p>
<p>NSlayoutConstraint 的类方法：</p>
<pre><code>[NSLayoutConstraint constraintWithItem:
                             <span class="keyword">attribute</span>:
                             relatedBy:
                                toItem:
                             <span class="keyword">attribute</span>:
                            multiplier:
                              <span class="keyword">constant</span>:
 ]
</code></pre><p>每次只创建一个约束，每个布局约束定义一个规则，可能涉及一个或者两个视图。</p>
<p>如果涉及到两个视图，那么上述约束将会创建一个严格的 <code>视图.属性 R 视图.属性 * 因数 + 常数</code> 的关系，其中关系 R 可以是等于或不等关系。</p>
<p>举个🌰</p>
<pre><code>[<span class="keyword">self</span><span class="variable">.view</span> addConstraint:
[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:<span class="keyword">self</span><span class="variable">.view</span>
                             attribute:<span class="built_in">NSLayoutAttributeCenterX</span>
                             relatedBy:<span class="built_in">NSLayoutRelationEqual</span>
                                toItem:textField
                             attribute:<span class="built_in">NSLayoutAttributeCenterX</span>
                            multiplier:<span class="number">1</span>
                              constant:<span class="number">0</span>
 ]];
</code></pre><p>该代码向视图控制器的视图（self.view）添加了一个约束，要求与 textField 输入框水平居中对齐。表达式如下：</p>
<p><code>[self.view]的 centerX = （[文本字段]的 centerX * 1） + 0</code></p>
<p>addConstraint 方法是将某个约束实例添加到视图中，类似与 IB 中 某个 View 下的 constraints</p>
<p>有一部分约束是只需一个视图的。例如指定宽度等。</p>
<p>约束至少需要与一个 View 有关系。</p>
<h3 id="视图项">视图项</h3><p>约束用 firstItem 和 secondItem 属性引用其所影响的视图，这些属性是只读的，只能在创建时期设置。可以拓展 NSLayoutConstraint 类（类别）来获取 NSLayoutConstraint 类实例的 firstItem 和 secondItem</p>
<h3 id="约束、层次结构与边界系统">约束、层次结构与边界系统</h3><blockquote>
<p>约束引用两个视图时，这两个视图必须在同一个视图层次结构，这个特别重要。</p>
<p>对于两个涉及视图的约束，只有两种情况，一种是父视图与子视图，另一种就是视图是平级的，即它们拥有相同的祖先视图。</p>
</blockquote>
<h3 id="安装约束">安装约束</h3><p>约束创建完成之后，还只是 NSLayoutConstraint 类的实例，如果想要约束生效，还需要将约束添加到 AutoLayout 系统，例如：</p>
<pre><code><span class="title">[myView addConstraint: aConstraintInstance]</span><span class="comment">;</span>
</code></pre><p>因为可视化格式系统返回的是约束实例数组，所以还提供另一种方式：</p>
<pre><code><span class="title">[myView addConstraints: myArrayConstraints]</span><span class="comment">;</span>
</code></pre><p>对于单个 item 的约束，安装到这个 item 对应 View 的本身，对于两个 Item，需要安装到它们最近的公共祖先视图上。</p>
<p>需要删除约束时，有一种办法是删除约束涉及的某个 view，然后 AutoLayout 系统会自动将所有涉及 view 的约束删除掉，即调用 [view removeFromSuperView];</p>
<p>还有一种就是 view 调用删除约束的方法，不过需要注意的是，这个时候传入的 constraint 实例必须是之前安装的实例，即两者的指针要相同。这个时候可能需要将之前安装的 constraint 实例保存后，才能正确的删除，不过也有一种办法就是搜索当前 View 中所有与希望删除约束等价的约束，然后将其删除。</p>
<p>因为，视图将约束按照对象存储，如果两个约束不在内存中的同一个位置，即使它们的规则一样，视图仍然认为它们是不同的。</p>
<h3 id="比较约束">比较约束</h3><p>前面提到过，所有的约束都是一种关系：</p>
<p><code>视图1.属性 （关系R）视图2.属性 * 因数 + 常数</code></p>
<p>这些属性有 priority、firstItem、firstAttribute、relation、secondItem、secondAttribute、multiplier 和 constant。</p>
<p>对两个约束，可以分别比较它们的这些属性来判断是否为等价的约束。</p>
<p>约束安装后，可以删除，也可以用新的规则来替换。</p>
<p>AutoLayout 使用约束创建动画时，很大部分是修改约束部分的常数来实现。</p>
<h3 id="布局约束法则">布局约束法则</h3><ul>
<li>布局约束具有优先级</li>
<li>布局约束没有天然顺序，所有具有相同优先级的约束都被同时考虑</li>
<li>布局约束是关系，没有方向</li>
<li>布局约束可以取近似值</li>
<li>布局约束可以循环</li>
<li>布局约束可以冗余（只要不发生冲突）</li>
<li>布局约束可以引用兄弟视图</li>
<li>AutoLayout 对变形的处理可能不是很好</li>
<li>AutoLayout 不支持 iOS7 新增的视图动态功能</li>
<li>AutoLayout 支持动画效果</li>
<li>布局约束不应在不同的边界系统之间交叉使用</li>
<li>布局约束会在运行时失败</li>
<li>格式不正确的约束会 crash</li>
<li>约束至少引用一个视图</li>
<li>小心无效的属性结对</li>
</ul>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/04/27/2015-04-27-ios-bing-fa-bian-cheng-zhi-nan-(er-)-operation-queue/" title="iOS 并发编程指南（二）- Operation Queue">iOS 并发编程指南（二）- Operation Queue</a></h2>
                <p class="excerpt">
                
                Cocoa operations 通过面向对象的方式封装了执行异步操作的工作。operations 是设计用来连接 operation queue。因为它们是基于 Objective-C 的，operations 常用于 iOS 和 OS X 中。
本章节描述了如何定义和使用 operations
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-04-27T02:58:41.000Z" class="post-list__meta--date date">2015-04-27</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/GCD/">GCD</a>, <a class="tag-link" href="/tags/并发编程/">并发编程</a>, <a class="tag-link" href="/tags/翻译/">翻译</a>
</span><a class="btn-border-small" href="/2015/04/27/2015-04-27-ios-bing-fa-bian-cheng-zhi-nan-(er-)-operation-queue/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/04/22/2015-04-22-autolayout-du-shu-bi-ji-1/" title="AutoLayout 读书笔记(一)">AutoLayout 读书笔记(一)</a></h2>
                <p class="excerpt">
                
                第一章 AutoLayout 介绍###1.1 由来：
前身为 Cassowary 约束解析工具包，本质是通过定义的约束构成联立方程组，然后求解，得出界面元素唯一的布局可能。
###1.2 好处都有啥？
几何关系
工作原理为通过创建界面上元素之间的关系从而实现布局。对于自然界之间的一些关系，可以用一些统一的规则来描述，能够建立界面元素之间强健的几何关系，在一定程度上使用抽象的语言描述。
改变 AutoLayout 约束的值，还可以创建出优美的动画。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-04-22T13:34:19.000Z" class="post-list__meta--date date">2015-04-22</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/AutoLayout/">AutoLayout</a>, <a class="tag-link" href="/tags/读书笔记/">读书笔记</a>
</span><a class="btn-border-small" href="/2015/04/22/2015-04-22-autolayout-du-shu-bi-ji-1/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 Well Cheng - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
