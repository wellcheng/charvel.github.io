<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Swift 学习笔记(一) | Charvel 互联网自留地</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="swift 这门语言一直想取深入了解下，苦于时间少，现在快毕业了，呆在学校时间还算比较充足，所以开始学习一哈。">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Swift 学习笔记(一) | Charvel 互联网自留地">
    <meta name="twitter:description" content="swift 这门语言一直想取深入了解下，苦于时间少，现在快毕业了，呆在学校时间还算比较充足，所以开始学习一哈。">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift 学习笔记(一) | Charvel 互联网自留地">
    <meta property="og:description" content="swift 这门语言一直想取深入了解下，苦于时间少，现在快毕业了，呆在学校时间还算比较充足，所以开始学习一哈。">

    
    <meta name="author" content="Well Cheng">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="Charvel 互联网自留地" href="/atom.xml">
    

    <link rel="canonical" href="http://blog.devcheng.com/2015/04/29/2015-04-29-swift-xue-xi-bi-ji-1/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Charvel 互联网自留地 的主页"><img src="/images/avatar.jpg" width="80" alt="Charvel 互联网自留地 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Charvel 互联网自留地">Charvel 互联网自留地</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">记录生活的点点滴滴，记录技术的淅淅沥沥</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description"></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/favourite">黄金屋</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  

  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/monniya" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/onlymonniya" title="Twitter" target="_blank">
      <i class="social fa fa-twitter"></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>


  <li class="navigation__item">
    <a href="mailto:chengwei3269@hotmail.com" title="Mail" target="_blank">
      <i class="social fa fa-envelope"></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-04-29T11:22:58.000Z" class="post-list__meta--date date">2015-04-29</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/Swift/">Swift</a>, <a class="tag-link" href="/tags/学习笔记/">学习笔记</a>
 </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Swift 学习笔记(一)</h1>
  </header>

  <section class="post">
    <blockquote>
<p>swift 这门语言一直想取深入了解下，苦于时间少，现在快毕业了，呆在学校时间还算比较充足，所以开始学习一哈。</p>
</blockquote>
<a id="more"></a>
<h2 id="基础部分">基础部分</h2><h3 id="常量和变量">常量和变量</h3><p>常量和变量必须在使用前说明，常量使用 let ，变量使用 var 声明，其定义与其他语言一致，强烈建立在使用不会变化的值时，将其声明为常量。</p>
<p>声明常量或者变量的时候还可以加上 <code>类型标注 (type annotation)</code>, 说明常量或者变量中值的类型，格式一般为常量(变量)名 + 冒号 + 空格 + 类型名称</p>
<pre><code><span class="keyword">var</span> userName: <span class="built_in">String</span> 
</code></pre><p>声明中的冒号其实就是 <code>是 ...  的类型</code>，所以上面代码可以理解为：</p>
<ul>
<li>“声明一个类型为 String，名字为 userName 的变量”</li>
<li>“类型为 String ” 的意思就是可以存储任意 String 类型的值</li>
</ul>
<p>现在，userName 变量可以被设置为任何 String 类型的值：</p>
<pre><code><span class="setting">userName = <span class="value"><span class="string">"Well Cheng"</span></span></span>
</code></pre><p>需要注意的是，绝大部分情况下，你是不需要去为变量或者常量去写类型标注的，因为在初始化的过程中，Swift 可以根据初始化的初值推断出其类型。上面的例子是因为声明时没有给 userName 赋值，而是在声明后赋值的，所以需要类型标注。实际中，应该是酱紫的：</p>
<pre><code><span class="variable"><span class="keyword">var</span> userName</span> =  <span class="string">"Well Cheng"</span>
</code></pre><p>Swift 能够根据你赋的初值 “Well Cheng” 推断出 userName 是 String 类型的变量，常量也是如此。</p>
<p>对于常量或者变量的命名，相信很多看过 WWDC 的开发者都惊讶了，表情竟然和也可以作为变量名，（字母或下划线开头什么的见鬼去吧~）。其实，因为表情是 Unicode 字符，所以才可以作为变量名。常量与变量名，不能包含数学符号、箭头、非法（保留）的 Unicode 码位、连线和制表符。当然，也不能以数字开头。</p>
<p>一旦常量和变量被声明后，一是不能再次被声明，二是不能改变其存储值的类型，三是不能改变常量的值，最后，常量和变量之间不能进行互转。</p>
<p>还有一点就是起名的时候，要注意不能与 Swift 的保留关键字冲突，实在实在没有办法可以使用反引号将其包住。</p>
<p>常量的值是可以改变为其他同类型的值，例如：</p>
<pre><code><span class="variable"><span class="keyword">var</span> userName</span> = <span class="string">"Well"</span>
userName = <span class="string">"Cheng"</span>
</code></pre><p>常量的值一旦确定不能改变：</p>
<pre><code><span class="keyword">let</span> languageName = <span class="string">"Swift"</span>
languageName = <span class="string">"Swift ++"</span>    <span class="comment">// 编译器报错</span>
</code></pre><p>可以使用 println 函数来输出常量或者变量的值，默认最后换行。<br>Swift 可以使用叫做<code>字符串插值(string interpolation)</code> 的方式把常量或者变量当做占位符插入到字符串中，格式为反斜杠后跟括号，括号里面为变量或常量名。</p>
<pre><code><span class="function"><span class="title">println</span><span class="params">(<span class="string">"current user name is \(userName)"</span>)</span></span>
</code></pre><h3 id="注释">注释</h3><p>单行注释双斜杠：<code>// 这是一条注释</code>，多行注释用 <em>/ 包含，例如 `/</em> 这里面可以放多行注释<em>/<code>。当然这些也都是其他语言有的，Swift 不同的是嵌套注释，即</code>/</em>` 是可以多层嵌套的，这样的话，以前大片大片的注释代码的时候，已经被注释掉的代码就不会出来闹眼子了。</p>
<h3 id="分号">分号</h3><p>在 Swift 中，分号是可以省略的，除了你在一行里面写了多条语句，如下：</p>
<pre><code><span class="keyword">let</span> <span class="keyword">cat</span> = <span class="string">"🐱"</span>; println(<span class="keyword">cat</span>)
</code></pre><h3 id="整数">整数</h3><p>整数就是没有小数部分的数字，Swift 提供了 8，16，32 和 64 位的有符号以及无符号整数类型。跟之前的 <code>UInt8</code>、 <code>Int32</code> 这些基本一致。</p>
<h4 id="整数范围">整数范围</h4><p>可以访问不同整数类型的 <code>min</code> 和 <code>max</code> 方法来获取</p>
<h4 id="Int">Int</h4><p>一般来说，在使用整型时，不需要专门指定其长度，因为有 Swift 提供的 Int 类型。</p>
<ul>
<li>32位：Int 与 Int32 长度相同</li>
<li>64位：Int 与 Int64 长度相同</li>
</ul>
<h4 id="UInt">UInt</h4><p>无符号整型：</p>
<ul>
<li>32位：UInt 与 UInt32 长度相同</li>
<li>64位：UInt 与 UInt64 长度相同</li>
</ul>
<p>需要注意的是，尽量不要使用 UInt，就算你知道这个值是非负的，这个与类型安全和类型推断有关，使用默认的 Int 真真是极好的。</p>
<h3 id="浮点数">浮点数</h3><p>Double 表示 64位浮点数，Float 为 32 位浮点数，根据你需要的精度正确选择即可。</p>
<h3 id="类型安全和类型判断">类型安全和类型判断</h3><p>Swift 是类型安全（type safe）的语言。类型安全的语言可以让你清楚的知道需要被处理的值的类型。Swift 因为是类型安全，所以会在安全期间进行类型检查。</p>
<p>如果没有显示的声明类型，Swift 还会使用类型推断来选择适合的类型。因为这个特性，所以 Swift 很少需要去声明类型。</p>
<p>在声明常量或者变量并初始化时，类型推断特别有用，它会按照你传入的字面量推断出其类型。例如：</p>
<pre><code><span class="keyword">let</span> meaningOfLife = <span class="number">22</span>
<span class="comment">// Swift 根据字面量 ‘22’ 推断出其类型为整型</span>
</code></pre><p>在推断浮点数时， Swift 默认选择 Double，这个应该是为了安全考虑<br>表达式中同时出现整数和浮点数时，推断为 Double</p>
<h3 id="数值型字面量">数值型字面量</h3><p>直接上代码，<br>这些是整数：</p>
<pre><code><span class="keyword">let</span> decimalInteger = <span class="number">17</span>
<span class="keyword">let</span> binaryInteger = <span class="number">0</span>b<span class="number">100101</span>    <span class="comment">// 二进制，0b 开头</span>
<span class="keyword">let</span> octalInteger = <span class="number">0</span>o<span class="number">164527</span>     <span class="comment">// 八进制，0o 开头</span>
<span class="keyword">let</span> hexadecimalInteger = <span class="number">0</span>x<span class="number">1</span>F<span class="number">2</span>C <span class="comment">// 十六进制，0x开头</span>
</code></pre><p>浮点数中，小数点两边必须要有数字，还可以采用科学计数法：</p>
<pre><code>let floatValue = <span class="number">1.24e2</span>    <span class="comment">// 1.25 x 10^2 即 125。0</span>
let hexFloatValue = <span class="number">0xF</span>p2    <span class="comment">// 15 x 2^2 即 60.0</span>

let decimalDouble = <span class="number">12.1875</span>
let exponentDouble = <span class="number">1.21875e1</span>
let hexadecimalDouble = <span class="number">0xC</span><span class="number">.3</span>p0
</code></pre><p>增加无用的 ‘0’ 和 下划线，并不影响字面量的值</p>
<h3 id="数值类型转换">数值类型转换</h3><p>经常使用默认的 Int 类型，可以保证你的整数常量和变量可以直接被复用，并且可以匹配整数类型字面量的类型推断。只有在必要的时候，才会使用其他整型类型。</p>
<h4 id="整数转换">整数转换</h4><p>不同类型的整数可以存储不同范围的值，所以你有时候必须要进行类型转换，而且是显示的，这种显示的类型转换有很多好处，这样子能够更加清楚的表达意图。</p>
<p>在类型转换时，使用目标类型转换数值，如下：</p>
<pre><code><span class="built_in">let</span> twoThousand: UInt16 = <span class="number">2</span>_000
<span class="built_in">let</span> one: UInt8 = <span class="number">1</span>
<span class="built_in">let</span> twoThousandAndOne = twoThousand + UInt16(one)
</code></pre><p>这种 <code>SomeType(ofInitalvalue)</code> 的形式，是调用 Swift 构造器并传入初始值的默认方法。其中的原理就是，UInt16 类型内部有一个可以接受 UInt8 类型的构造器，所以能够对 UInt8 类型进行转换。如果需要转换的目标类型不存在对应构造器是不能转换的。不过你可以使用拓展来增加一个。</p>
<h4 id="整数和浮点数转换">整数和浮点数转换</h4><p>两者的相互转换都需要显示的转换，不过在使用数值字面量的时候，不需要，例如</p>
<pre><code>let π = <span class="number">3</span> + <span class="number">0.14</span>
</code></pre><p>因为字面量本身是没有类型的，编译器会推断它的类型(π被推导为 Double 类型)</p>
<h3 id="类型别名">类型别名</h3><p>类型别名（type aliases）就是给现有的类型起另外一个名字，使用 <code>typealias</code> 关键字定义，实际运用中主要为方面理解，我的个人理解编译器编译时会使用真实的类型替换掉别名。</p>
<h3 id="布尔值">布尔值</h3><p>Swift 中布尔类型为 Bool，即逻辑上的真假，有 true 和 false，在需要使用 Bool 类型的地方使用别的值会报错，如下：</p>
<pre><code>let i = <span class="number">1</span>
<span class="keyword">if</span> i {
    <span class="comment">// 报错，Swift 没有隐形的类型转换</span>
}

<span class="function"><span class="keyword">if</span> <span class="title">Bool</span><span class="params">(i)</span> </span>{
    <span class="comment">// 正确</span>
}

<span class="keyword">if</span> i == <span class="number">1</span> {
    <span class="comment">// 正确</span>
}
</code></pre><h3 id="元组">元组</h3><p>元组（tuples）把多个值组合成为一个复合值。元组内的值是任意类型，不要求是相同类型。</p>
<p>例如，（404，“Not Found”） 是一个 HTTP 状态码的元组</p>
<pre><code><span class="built_in">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)
</code></pre><p>上面 http404Error 的类型为元组 （Int，String），也可以将元组的内容分解为单独的变量或常量</p>
<pre><code>let <span class="list">(<span class="keyword">statusCode</span>, statusMessage)</span> = http404Error
println<span class="list">(<span class="keyword">the</span> error code = \<span class="list">(<span class="keyword">statusCode</span>)</span> and info is \<span class="list">(<span class="keyword">statusMesage</span>)</span>)</span>
</code></pre><p>如果只需要元组中其中一部分的值，可以将需要忽略的部分用下划线替换 （_）:</p>
<pre><code>let <span class="list">(<span class="keyword">code</span>, _)</span> = http404Error
</code></pre><p>还可以使用下标访问单个元素：</p>
<pre><code>let <span class="tag">code</span> = http404Error.<span class="number">0</span>
</code></pre><p>还可以定义元组时给其命名，之后使用名称访问：</p>
<pre><code>let http200Status = (<span class="tag">code</span>: <span class="number">200</span>, des: <span class="string">"OK"</span>)

<span class="function"><span class="title">println</span><span class="params">(<span class="string">"code is (\http200Status.code) and info is \(http200Status.des)"</span>)</span></span>
</code></pre><p>元组经常用于函数返回，当有多个值需要返回时，可以将其组装为一个元组</p>
<blockquote>
<p>元组在临时使用时很方便，如果你的程序中有多处用到相同类型的元组，需要考虑用类或者结构体将其重新定义</p>
</blockquote>
<h3 id="可选类型">可选类型</h3><p>可选类型（optionals）用来处理值可能缺失的情况。可选类型表示，有值就等于本身，或者没有值时为可选值或者 nil（此时的 nil 不同于 OC ，Swift 中 nil 可以表示任何类型的值缺失情况）</p>
<h4 id="if_语句以及强制解析">if 语句以及强制解析</h4><p>可以使用 if 语句来判断一个可选是否包含值，如果可选类型有值，返回 true；没有值时返回 false，当确定其有值后，可以使用 ！来表示我确定这个可选类型是存在值的，你编译器就当做正常的值来调用吧。这个过程称为强制解析：</p>
<pre><code><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span>
<span class="keyword">if</span> convertedNumber = possibleNumber.toInt()    <span class="comment">// convertedNumber 类型推断为 “Int?” ,表示一个可选类型，因为编译期间无法确定 possibleNumber 能否被正确转换</span>

<span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> {
    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(possibleNumber)</span> has a integer value of <span class="subst">\(convertedNumber!)</span>"</span>)    <span class="comment">// 使用感叹号</span>
} <span class="keyword">else</span> {
    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(possibleNumber)</span> could not be converted to an integer"</span>)
}
</code></pre><p>如果你使用了 ！，但是运行期间值并不存在，那么会导致运行期间发生错误，所以一定要使用 if 语句来判断</p>
<h4 id="可选绑定">可选绑定</h4><p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给临时常量或者变量。常用语 if  while 语句：</p>
<pre><code><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional {
    <span class="attribute">...</span>
}
</code></pre><p>重写上面的例子:</p>
<pre><code><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = possibleNumber.toInt() {
    <span class="comment">// use actualNumber</span>
} <span class="keyword">else</span> {
    <span class="comment">// handle error</span>
}
</code></pre><p>if 语句的意思就是，“如果possibleNumber.toInt返回的可选Int包含一个值，创建一个叫做actualNumber的新常量并将可选包含的值赋给它。”，然后就可以在第一个分支使用新的常量值了，这样子做的好处就是，使用了新的常量来存储，不必像之前那样加 ！来告诉编译器，对于使用 let 还是 var 根据你的实际情况，如果接下来的任务中需要对 actualNumber 做修改，那么使用 var</p>
<h4 id="nil">nil</h4><p>可以使用 nil 给可选变量表示没有值：</p>
<pre><code><span class="variable"><span class="keyword">var</span> serverResponseCode</span>: <span class="typename">Int</span>? = <span class="number">404</span>
<span class="comment">// serverResponseCode 包含一个可选的 Int 值 404</span>
serverResponseCode = nil
<span class="comment">// serverResponseCode 现在不包含值</span>
</code></pre><p>需要注意的是，nil 不能用于非可选的常量和变量。</p>
<p>如果声明的可选常量或变量没有赋值，默认设置为 nil。</p>
<p><em>Swift 的nil和 Objective-C 中的nil并不一样。在 Objective-C 中，nil是一个指向不存在对象的指针。在 Swift 中，nil不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为nil，不只是对象类型</em></p>
<h4 id="隐式解析可选类型">隐式解析可选类型</h4><p>上面我们学习过了，可选类型暗示了常量或者变量可以 “没有值“，然后在实际处理中通过 if 语句来判断，但是很多情况下，一开始是没有值的，后来我很确定有值了，如果仍然像之前那样子判断，是一种很低效的方法。</p>
<p>这种类型的可选状态定义为 <code>隐式解析可选类型（implicitly unwrapped optionals）</code>，将可选类型后面的 ？ 改为 ！ 即表示我当前声明的时一个隐式解析可选类型。</p>
<p>隐式解析可选类型可以当做非可选类型处理，也可以当做可选类型处理。</p>
<h3 id="断言">断言</h3><p>可选类型判断值是否存在，然后在代码中优雅的处理值确实的情况，然而有的时候值缺失或者不满足条件的情况下，代码可能无法继续执行，这个时候可以使用断言（assertion）结束代码运行并通过调试找到值缺失的原因。</p>
<h4 id="使用断言进行调试">使用断言进行调试</h4><p>断言即在运行时判断逻辑条件，可以附加一条调试信息：</p>
<pre><code>let age = -<span class="number">3</span>
<span class="function"><span class="title">assert</span><span class="params">(age &gt;= <span class="number">0</span>,<span class="string">"年龄不能小于 0 "</span>)</span></span>
</code></pre><p>在执行到这些代码时，如果断言被满足，即 age &gt;= 0 ,那么代码继续执行，如果断言不满足，那么停止运行并且输出后面的这句调试信息。</p>
<h4 id="什么时候使用断言">什么时候使用断言</h4><p>当你认为某个条件可能为假时，可以使用断言来调试，一般有以下场景：</p>
<ul>
<li>整数类型的下标索引可能太大太小</li>
<li>给函数传值，但是非法的值会导致函数不能正常执行</li>
<li>一个可选值现在为 nil ，但是之后的代码需要一个非 nil 的值</li>
</ul>
<blockquote>
<p>在测试应用时很方便，上线 AppStore 时，还是需要将其注释掉</p>
</blockquote>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/04/30/2015-04-30-autolayout-du-shu-bi-ji-san-ke-shi-hua-ge-shi/" title="AutoLayout 读书笔记(三)-可视化格式">AutoLayout 读书笔记(三)-可视化格式</a></h2>
                <p class="excerpt">
                
                AutoLayout 目前有三种创建约束的方式，第一种为 IB 中手动创建、第二种为代码中使用 NSLayoutConstraint 类，现在我们学习第三种，使用 格式化语言 创建约束。
需要记住的是，不管何种方式创建的约束，都是 NSLayoutConstraint 类的实例，并且遵循 y = mx + b 关系
可视化约束的格式介绍NSLayoutConstraint 类方法创建可视化的约束，尽管可视化约束的内容能够关联多个视图，但是它们会被 NSLayoutConstraint 翻译为每次只关联一个或多个视图。这种方式创建的约束为数组的形式。
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-04-30T06:22:42.000Z" class="post-list__meta--date date">2015-04-30</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/AutoLayout/">AutoLayout</a>
</span><a class="btn-border-small" href="/2015/04/30/2015-04-30-autolayout-du-shu-bi-ji-san-ke-shi-hua-ge-shi/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2015/04/27/2015-04-27-ios-bing-fa-bian-cheng-zhi-nan-(er-)-operation-queue/" title="iOS 并发编程指南（二）- Operation Queue">iOS 并发编程指南（二）- Operation Queue</a></h2>
                <p class="excerpt">
                
                Cocoa operations 通过面向对象的方式封装了执行异步操作的工作。operations 是设计用来连接 operation queue。因为它们是基于 Objective-C 的，operations 常用于 iOS 和 OS X 中。
本章节描述了如何定义和使用 operations
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2015-04-27T02:58:41.000Z" class="post-list__meta--date date">2015-04-27</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/GCD/">GCD</a>, <a class="tag-link" href="/tags/并发编程/">并发编程</a>, <a class="tag-link" href="/tags/翻译/">翻译</a>
</span><a class="btn-border-small" href="/2015/04/27/2015-04-27-ios-bing-fa-bian-cheng-zhi-nan-(er-)-operation-queue/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 Well Cheng - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
