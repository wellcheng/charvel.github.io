<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>AutoLayout 读书笔记(三)-可视化格式 - Even - A super concise theme for Hugo</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="Charvel"><meta name=description content="AutoLayout 目前有三种创建约束的方式，第一种为 IB 中手动创建、第二种为代码中使用 NSLayoutConstraint 类，现在我们学习第三种，使用 格式化语言 创建约束。
需要记住的是，不管何种方式创建的约束，都是 NSLayoutConstraint 类的实例，并且遵循 y = mx + b 关系
可视化约束的格式介绍 NSLayoutConstraint 类方法创建可视化的约束，尽管可视化约束的内容能够关联多个视图，但是它们会被 NSLayoutConstraint 翻译为每次只关联一个或多个视图。这种方式创建的约束为数组的形式。
"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.110.0 with theme even"><link rel=canonical href=http://wellcheng.github.io/post/2015-04-30-autolayout-du-shu-bi-ji-san-ke-shi-hua-ge-shi/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="AutoLayout 读书笔记(三)-可视化格式"><meta property="og:description" content="AutoLayout 目前有三种创建约束的方式，第一种为 IB 中手动创建、第二种为代码中使用 NSLayoutConstraint 类，现在我们学习第三种，使用 格式化语言 创建约束。
需要记住的是，不管何种方式创建的约束，都是 NSLayoutConstraint 类的实例，并且遵循 y = mx + b 关系
可视化约束的格式介绍
NSLayoutConstraint 类方法创建可视化的约束，尽管可视化约束的内容能够关联多个视图，但是它们会被 NSLayoutConstraint 翻译为每次只关联一个或多个视图。这种方式创建的约束为数组的形式。"><meta property="og:type" content="article"><meta property="og:url" content="http://wellcheng.github.io/post/2015-04-30-autolayout-du-shu-bi-ji-san-ke-shi-hua-ge-shi/"><meta property="article:section" content="post"><meta property="article:published_time" content="2015-04-30T14:22:42+08:00"><meta property="article:modified_time" content="2015-04-30T14:22:42+08:00"><meta itemprop=name content="AutoLayout 读书笔记(三)-可视化格式"><meta itemprop=description content="AutoLayout 目前有三种创建约束的方式，第一种为 IB 中手动创建、第二种为代码中使用 NSLayoutConstraint 类，现在我们学习第三种，使用 格式化语言 创建约束。
需要记住的是，不管何种方式创建的约束，都是 NSLayoutConstraint 类的实例，并且遵循 y = mx + b 关系
可视化约束的格式介绍
NSLayoutConstraint 类方法创建可视化的约束，尽管可视化约束的内容能够关联多个视图，但是它们会被 NSLayoutConstraint 翻译为每次只关联一个或多个视图。这种方式创建的约束为数组的形式。"><meta itemprop=datePublished content="2015-04-30T14:22:42+08:00"><meta itemprop=dateModified content="2015-04-30T14:22:42+08:00"><meta itemprop=wordCount content="2728"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="AutoLayout 读书笔记(三)-可视化格式"><meta name=twitter:description content="AutoLayout 目前有三种创建约束的方式，第一种为 IB 中手动创建、第二种为代码中使用 NSLayoutConstraint 类，现在我们学习第三种，使用 格式化语言 创建约束。
需要记住的是，不管何种方式创建的约束，都是 NSLayoutConstraint 类的实例，并且遵循 y = mx + b 关系
可视化约束的格式介绍
NSLayoutConstraint 类方法创建可视化的约束，尽管可视化约束的内容能够关联多个视图，但是它们会被 NSLayoutConstraint 翻译为每次只关联一个或多个视图。这种方式创建的约束为数组的形式。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Even</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Even</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>AutoLayout 读书笔记(三)-可视化格式</h1><div class=post-meta><span class=post-time>2015-04-30</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#可视化约束的格式介绍>可视化约束的格式介绍</a></li><li><a href=#选项>选项</a><ul><li><a href=#对齐>对齐</a></li><li><a href=#变量绑定>变量绑定</a></li><li><a href=#度量>度量</a></li><li><a href=#格式字符串结构>格式字符串结构</a></li><li><a href=#方向>方向</a></li><li><a href=#视图名称>视图名称</a></li><li><a href=#连接>连接</a></li><li><a href=#视图尺寸>视图尺寸</a></li><li><a href=#格式字符串部件>格式字符串部件</a></li><li><a href=#错误>错误</a></li><li><a href=#nslog-和可视化格式>NSLog 和可视化格式</a></li></ul></li><li><a href=#约束到父视图>约束到父视图</a></li><li><a href=#视图拉伸>视图拉伸</a></li><li><a href=#约束尺寸>约束尺寸</a></li><li><a href=#创建一行或者一列>创建一行或者一列</a></li><li><a href=#匹配尺寸>匹配尺寸</a></li><li><a href=#为什么不能够分布视图>为什么不能够分布视图</a></li></ul></li></ul></nav></div></div><div class=post-content><p>AutoLayout 目前有三种创建约束的方式，第一种为 IB 中手动创建、第二种为代码中使用 NSLayoutConstraint 类，现在我们学习第三种，使用 <code>格式化语言</code> 创建约束。</p><p>需要记住的是，不管何种方式创建的约束，都是 NSLayoutConstraint 类的实例，并且遵循 <code>y = mx + b</code> 关系</p><h2 id=可视化约束的格式介绍>可视化约束的格式介绍</h2><p>NSLayoutConstraint 类方法创建可视化的约束，尽管可视化约束的内容能够关联多个视图，但是它们会被 NSLayoutConstraint 翻译为每次只关联一个或多个视图。这种方式创建的约束为数组的形式。</p><p>可视化格式，由一个描述布局方式的文本字符串组成。根据约束关联项在视图中出现的顺序一次列出它们。文本序列指定间隔、不等量和优先级。看代码比较直接：</p><pre><code>[self.view addConstraints:[NSLayoutConstraint constraintWithVisualFormat:@&quot;V:[view1]-8-[view2]&quot;]]
    options:NSLayoutFormatAlignAllLeading
    metrics:nil
    views:[NSDictionaryOfVariableBings(view1,view2)]
];
</code></pre><p>上面代码创建的约束为：在 View1 和 View2组成的左对齐一列，间距为 8 ，下面是几点说明：</p><ul><li>坐标轴：作为前缀指定，H-水平，V-垂直，如果不指定，默认为 H，但是强烈建议显示指定</li><li>每个视图的变量名出现在方括号中，包起来</li><li>视图出现的顺序，与布局系统中请求的顺序匹配，一般为从左到右</li><li>两个视图的间隔以固定数字出现</li><li>选型参数指定对齐方式</li><li>metrics 没用到</li><li>views 表示真实对象与布局格式中 View 的绑定关系，一般使用语义化的词语来绑定真实的对象</li></ul><p>为什么要使用这种方式呢，首先，简洁，使用这种方式创建的约束可能需要之前实例化 NSLayoutConstraint 方式好几个才行。第二是高度抽象，即当前表示的布局方式是基于一个比较高的角度去考虑。第三，很容易调整。</p><h2 id=选项>选项</h2><p>可视化格式方法的选项，包括 对齐掩码、格式方向掩码</p><h3 id=对齐>对齐</h3><p>应当总是正交地使用掩码，比如在水平方向上创建了一行 view ，那么需要顶部对齐，基准线对齐，或者中心对齐</p><p>有些地方可以省略，例如给 options 传入 0，这个时候，只会创建可视化的约束，不建立对齐约束</p><h3 id=变量绑定>变量绑定</h3><p>将布局系统中表示视图的字符串与实际的对象绑定起来，使用 NSDictionaryOfVariableBindings（）宏来创建绑定。</p><p>你也可以自己来创建字典。但是字典对于视图数组很不友好，会在解析时出现问题。因为可视化格式对于一些步骤比较长的视图解析起来有些力不从心，例如 [self.view viewWithTag:100] 等。</p><p>为了解决上面的问题，可以使用代码创建字典和格式字符串，上代码：</p><pre><code>// 初始化格式字符串和绑定字典  
NSMutableString *formatString = [NSMutableString string];  
NSMutableDictionary *bindings = [NSMutableDictionary dictionary]; 

// 视图数量 int i = 1; 
// 创建一行视图，Build a format string that lays out the views in a row 
// e.g. @&quot;H:|-[view1] [view2]-[view3]...&quot; 
[formatString appendString:@&quot;H:|-&quot;]; 
for (UIView *view in views) { 
    // 创建一个视图的名字 
    NSString *viewName = [NSString stringWithFormat:@&quot;view%0d&quot;, i++]; 
    
    // 将这个视图添加到格式化字符串中 
    [formatString appendFormat:@&quot;[%@]%@&quot;,viewName, (i &lt;= views.count) ? @&quot;-&quot; : @&quot;&quot;]; 
    
    // 将视图的名称与对象做绑定 
    bindings[viewName] = view; 
}
</code></pre><h3 id=度量>度量</h3><p>如果一开始不知道某个常量的值，可以使用度量字典提供的值。例如</p><pre><code>@&quot;V:[view1]-spacing-[view2]&quot;
</code></pre><p>以后知道了值时，创建一个字典对象将其关联起来，传递给 metrics：</p><pre><code>NSDictionary *metrics = @{@&quot;spacing&quot;:@10};
[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:[view1]-spacing-[view2]&quot;
    options: ...
    metrics:metrics
    views:bindings
]
</code></pre><p>在实际开发中，这个很有用，可以写一些可以复用的代码：</p><pre><code>- (void)constrainView:(UIView *)view toWidth:(CGFloat) width {
    NSString *formatString = @&quot;H:[view(==width)]&quot;;    // 创建约束字符串
    NSDictionary *bindings = NSDictionaryOfVariableBindings(view);
    NSDictionary *metrics = @{@&quot;width&quot;:@(width)};
    
    NSArray *constraints = [NSLayoutConstraint constraintsWithVisualFormat ...
    
    [view addConstraints:constraints];
}
</code></pre><h3 id=格式字符串结构>格式字符串结构</h3><p>前面我们已经接触了很多次格式化字符串的结构，大概也能猜到一些，具体的语法为：</p><pre><code>(&lt;orientation&gt;:)? 
(&lt;superView&gt;&lt;connection&gt;)? 
&lt;view&gt;(&lt;conection&gt;&lt;view&gt;)* 
(&lt;connection&gt;&lt;superview&gt;)?
</code></pre><p>看起来很复杂，其实用到后面就会觉得简单了，<code>？</code>表示可选，<code>*</code> 表示0个或多个</p><h3 id=方向>方向</h3><p>可视化格式，以一个方向开始，可以是 H：水平方向，V：垂直方向</p><h3 id=视图名称>视图名称</h3><p>视图名称被方括号包围，使用变量绑定视图名时，视图名称指的是视图本身的变量名</p><p>使用竖线 <code>|</code> 来表示父视图，一般出现在格式字符串的开头或者结尾，开头时，一般出现在 <code>H:| ...</code>，结尾时，一般为最后一个引号之前</p><p>下面是几个典型的例子：</p><ul><li>使当前视图按照父视图延伸（水平或者垂直）：<code>"H:|[view]|"</code></li><li>某个视图偏移父视图的某条边：<code>"V:[view]-10-|"</code>,表示距离父视图底部 10 间隔</li><li>创建一行或者一列与父视图对齐的视图：<code>"V:|-[view1]-[view2]-[view3]-|"</code></li></ul><h3 id=连接>连接</h3><p>连接表示了视图之间的间隔</p><h4 id=空连接>空连接</h4><p>一般是 <code>[view1][view2]</code> 这种形式，表示紧挨着</p><h4 id=标准间隔>标准间隔</h4><p>这个时候使用连字符 <code>-</code> 代表固定的间隔，例如：</p><pre><code>&quot;H:|-[view1]-[view2]&quot;
</code></pre><p>表示 view1 和 view2 水平方向上标准的间隔，视图与视图之间为 8 ，子视图与父视图之间为 20</p><h4 id=数字间隔>数字间隔</h4><p>可以在两个连字符中间插入数字表示准确的间隔值，如 <code>[view1]-30-[view2]</code> 。</p><h4 id=引用父视图>引用父视图</h4><p>使用 <code>|</code> 表示父视图，例如 <code>"H:|[view1]-[view2]|"</code> 表示 view1 和 view2 之间有标准间隙，并且view1 的左边与父视图左边界相邻，view2 右边与父视图右边相邻，必须要制定 view1 或 view2 其中一个的宽度，不要会发生歧义。</p><h4 id=与父视图的间隔>与父视图的间隔</h4><p>加入连字符或者带数字的连字符即可，例如 <code>"H:|-[view1]-[view2]-30-|"</code></p><h4 id=可变的间隔>可变的间隔</h4><p>有的时候，我们需要在两个视图之间加入一个可变的间隔。例如 <code>"H:|-[view1]-(>=0)-[view2]-|"</code> 表示，view1 和 view2 保持自己的尺寸，这个间隔最少为0 ，可以拉伸。</p><h4 id=圆括号>圆括号</h4><p>上面的例子中，大于等于关系包含在圆括号中，主要是有些数值可能带有负号，防止与连线符混淆。</p><p>对于同一种布局方式，有很多表示。例如表示两个视图相邻：</p><ul><li>[view1][view2]</li><li>[view1]-0-[view2]</li><li>[view1]-(0)-[view2]</li><li>[view1]-(==0)-[view2]</li><li>[view1]-(>=0,&lt;=0)-[view2]</li><li>[view1]-(==0@1000)-[view2]</li><li>[view1]-(>=0,&lt;=0,==0,&lt;=30)-[view2]</li></ul><p>关系后跟 <code>@</code> 表示优先级，多个关系可以用逗号隔开</p><h4 id=负数>负数</h4><p>为任何使用负数值的间隔加上括号，负数还有其他用途：<code>V:[view1]-(-10)-[view2]</code> 表示view1 下边缘往上10点为 view2 上边缘，这样子 view1 view2 垂直方向上有 10 点的重合。</p><h4 id=优先级>优先级</h4><p>在数值或者关系上使用@添加优先级，一般为清晰起见，加上括号比较好。</p><h4 id=多视图>多视图</h4><p>可以在格式字符串中插入多个视图</p><h3 id=视图尺寸>视图尺寸</h3><p>方括号中除了表示视图名称，还可以指定尺寸，例如 <code>H:[view(100)]</code> 表示宽度 100，同样，也可以使用关系。</p><p>视图尺寸也可以加优先级，或者是某个视图的倍数</p><h3 id=格式字符串部件>格式字符串部件</h3><p>如下表总结，可以使用逗号将其组合起来：</p><p><img src=http://7vzucb.com1.z0.glb.clouddn.com/blog.VisualFormatStrings-1.png alt="Visual Format Strings-1">
<img src=http://7vzucb.com1.z0.glb.clouddn.com/blog.VisualFormatStrings-2.png alt="Visual Format Strings-2"></p><blockquote><p>ios7 和 Xcode5 引入的 TopLayoutGuide 和 bottomLayoutGuide 需要先设置为本地变量然后再引用</p></blockquote><h3 id=错误>错误</h3><p>Xcode 无法提供编译器的检查，所以需要你注意控制台中的错误提示。</p><h3 id=nslog-和可视化格式>NSLog 和可视化格式</h3><p>有时候 Xcode 能够输出约束的可视化格式，有时候不行</p><h2 id=约束到父视图>约束到父视图</h2><p>可以使用代码方便的为父视图添加可视化字符串式的约束。
可以在 ViewWillDidAppear 中打印出所有 view 的 frame</p><pre><code>void constrainToSuperview(UIView *view, float minimumSize, NSUInteger priority) {
    if (!view || !view.superview) { 
        return; 
    } 
    
    for (NSString *format in @[  
        @&quot;H:|-&gt;=0@priority-[view(==minimumSize@priority)]&quot;,  
        @&quot;H:[view]-&gt;=0@priority-|&quot;, 
        @&quot;V:|-&gt;=0@priority-[view(==minimumSize@priority)]&quot;, 
        @&quot;V:[view]-&gt;=0@priority-|&quot;])  
    { 
        NSArray *constraints = [NSLayoutConstraint 
            constraintsWithVisualFormat:format options:0 
            metrics: @{@&quot;priority&quot;:@(priority), 
            @&quot;minimumSize&quot;:@(minimumSize)} 
            views:@{@&quot;view&quot;: view}]; 
            [view.superview addConstraints:constraints];  
        } 
    }
</code></pre><h2 id=视图拉伸>视图拉伸</h2><p>将视图向它们的父视图拉伸</p><pre><code>void stretchToSuperview(VIEW_CLASS *view, CGFloat indent, NSUInteger priority) {        
    for (NSString *format in @[
            @&quot;H:|-indent-[view]-indent-|&quot;,
            @&quot;V:|-indent-[view]-indent-|&quot; ]) {
        NSArray *constraints = [NSLayoutConstraint
                constraintsWithVisualFormat:format 
                options:0 metrics:@{@&quot;indent&quot;:@(indent)}
                views:@{@&quot;view&quot;: view}];
        for (NSLayoutConstraint *constraint in constraints) {
            constraint.priority = priority;
            [view.superview addConstraint:constraint];
        }
    }
}
</code></pre><h2 id=约束尺寸>约束尺寸</h2><p>将视图固定为制定的尺寸值</p><pre><code>void constrainViewSize(VIEW_CLASS *view, CGSize size, NSUInteger priority) {
    NSDictionary *bindings = NSDictionaryOfVariableBindings(view); 
    NSDictionary *metrics = @{
        @&quot;width&quot;:@(size.width),
        @&quot;height&quot;:@(size.height),
        @&quot;priority&quot;:@(priority)
    };
    for (NSString *formatString in @[ 
        @&quot;H:[view(==width@priority)]&quot;, 
        @&quot;V:[view(==height@priority)]&quot;, ]) {
        NSArray *constraints = [NSLayoutConstraint
            constraintsWithVisualFormat:formatString
            options:0 metrics:metrics views:bindings];
        [view addConstraints:constraints];
    }
}
</code></pre><h2 id=创建一行或者一列>创建一行或者一列</h2><p>创建视图，排成一行或者一列：</p><pre><code>#define IS_HORIZONTAL_ALIGNMENT(ALIGNMENT) 
\[@[@(NSLayoutFormatAlignAllLeft), @(NSLayoutFormatAlignAllRight),
\@(NSLayoutFormatAlignAllLeading), @(NSLayoutFormatAlignAllTrailing),
\@(NSLayoutFormatAlignAllCenterX)] containsObject:@(ALIGNMENT)]    

void buildLineWithSpacing(NSArray *views, NSLayoutFormatOptions alignment, NSString *spacing, NSUInteger priority)
{
    if (views.count == 0)
        return;
    
    VIEW_CLASS *view1, *view2;
    // Calculate the axis and its string representation. 
    // The axis is orthogonal to the requested alignment 
    // eg, centerX alignment creates a column, and
    // trailing builds a row.
    BOOL axisIsH = IS_HORIZONTAL_ALIGNMENT(alignment);
    NSString *axisString = (axisIsH) ? @&quot;H:&quot; : @&quot;V:&quot;;
    // Build the format
    NSString *format = [NSString
        stringWithFormat:@&quot;%@[view1]%@[view2]&quot;, axisString, spacing];
    // Apply the format to view pairs
    for (int i = 1; i &lt; views.count; i++) {
        view1 = views[i-1];
        view2 = views[i];
        NSDictionary *bindings = NSDictionaryOfVariableBindings(view1, view2);
        NSArray *constraints = [NSLayoutConstraint 
        constraintsWithVisualFormat:format options:alignment
            metrics:nil views:bindings];
        for (NSLayoutConstraint *constraint in constraints)
            [constraint install:priority];
    }
}
</code></pre><h2 id=匹配尺寸>匹配尺寸</h2><p>传入一个视图，然后将其他所有视图与第一个匹配</p><h2 id=为什么不能够分布视图>为什么不能够分布视图</h2><p>可能很多时候，你希望沿着某个方向等间隔的分布视图，这个无法做到的原因就是，约束同时最多引用两个视图。
这个时候，有两种 hack 的方式，一种是先将总宽度分为 N 个区域，然后每个区域中心点放置一个视图。但是如果视图之间的尺寸不一致时，效果会大打折扣。还有一种方法就是用透明的 View 来充当间隔。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Charvel</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2015-04-30</span></p></div><footer class=post-footer><nav class=post-nav><a class=prev href=/post/2015-04-30-ios-bing-fa-bian-cheng-zhi-nan-san-dispatch-queues/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">iOS 并发编程指南(三)-Dispatch Queues</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/2015-04-29-swift-xue-xi-bi-ji-1/><span class="next-text nav-default">Swift 学习笔记(一)</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:your@email.com class="iconfont icon-email" title=email></a>
<a href=http://localhost:1313 class="iconfont icon-stack-overflow" title=stack-overflow></a>
<a href=http://localhost:1313 class="iconfont icon-twitter" title=twitter></a>
<a href=http://localhost:1313 class="iconfont icon-facebook" title=facebook></a>
<a href=http://localhost:1313 class="iconfont icon-linkedin" title=linkedin></a>
<a href=http://localhost:1313 class="iconfont icon-google" title=google></a>
<a href=http://localhost:1313 class="iconfont icon-github" title=github></a>
<a href=http://localhost:1313 class="iconfont icon-weibo" title=weibo></a>
<a href=http://localhost:1313 class="iconfont icon-zhihu" title=zhihu></a>
<a href=http://localhost:1313 class="iconfont icon-douban" title=douban></a>
<a href=http://localhost:1313 class="iconfont icon-pocket" title=pocket></a>
<a href=http://localhost:1313 class="iconfont icon-tumblr" title=tumblr></a>
<a href=http://localhost:1313 class="iconfont icon-instagram" title=instagram></a>
<a href=http://localhost:1313 class="iconfont icon-gitlab" title=gitlab></a>
<a href=http://localhost:1313 class="iconfont icon-bilibili" title=bilibili></a>
<a href=http://wellcheng.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2017 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>Charvel</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>