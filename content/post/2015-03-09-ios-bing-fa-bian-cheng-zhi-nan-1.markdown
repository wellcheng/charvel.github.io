---
layout: post
title: "iOS 并发编程指南(一)"
date: 2015-03-09 15:38:28 +0800

categories: ['iOS']
tags: [并发编程, GCD, 翻译]
---

> 本文为翻译苹果官方文档，旨在自我学习，翻译之处会有坑，请酌情参考


## 简介

并发是指多件事情同时发生。随着多核 CPU 的实现，每个处理器上的核心只会增加，开发人员需要新的方式来充分利用它们。尽管像 OS X 和 iOS 这样的操作系统（自卖自夸，别的 OS 被你吃了吗？）能够并行的运行多个程序，其中大多数的程序运行在后台，并且经常需要一小段 CPU 时间来执行任务。运行在前台的程序与用户交互并且占用大量的 CPU 时间。如果一个程序有很多任务去做但是只有一部分内核可以使用，那么额外的计算资源将被浪费。

在过去，在程序中引入并发需要创建额外的一个或多个线程。不幸的是，写线程级别的代码很具有挑战性。线程是很底层的工具，必须手动来管理。对于一个程序，由于线程的最佳数目基于系统负载和底层硬件动态改变，实现一个正确的线程解决方案是非常困难的。此外，线程的同步机制通常会给软件设计增加复杂性和带来风险，并不能保证一定会提高程序性能。

相比较传统的基于线程的系统和应用程序，OS X 和 iOS 更多地采用异步方法来执行并行的任务。应用程序只需要定义特定的任务，然后让系统执行它们，而不是直接创建线程。通过让操作系统来管理线程，使得应用程序具有了原生线程不可能带来的可扩展性。开发者也有了更加简单高效的编程模式。

本文档描述了并发编程的技术和技巧，使用与 OS X 和 iOS。

文档包含以下章节：

- 并行和程序设计：介绍了基本的异步程序设计和异步执行自定义任务的技巧
- Operation Queues（操作队列）：指出如何使用 Objective-C 对象封装任务并且执行
- Dispatch Queue（分发队列）：如何并行的执行任务在 C 语言编程中
- Dispatch Sources：如何异步的处理系统时间
- Migrating Away from Threads：介绍如何将已存在的基于线程的代码迁移至新的技术上。

<!--more-->

## 并发和程序设计

在早期的计算机中，每一台计算机执行最小任务需要的时间单元取决于 CPU 的时钟速度，但随着技术的发展和处理器核心越来密集，散热和其他物理因素开始限制 CPU 的最大时钟速度。所以芯片制造厂商开始寻求其他的方式来增加芯片的总体性能。解决办法为增加每个芯片上的处理器核心数量，这样单个芯片的处理速度将得到提升，剩下的问题就是如何利用额外的核心。

为了利用多核，计算机需要软件能够同时干多件事情。现代的多任务操作系统，可以有上百的程序在给定的时间内运行，所以调度每个程序执行在不同的核上是可能的。然而，大多数的程序属于系统驻守进程，或那些运行在后台，只需要很少 CPU 时间的程序。相反，真正的需要是为单个应用程序高效的使用额外的核心。

应用程序利用多核的传统方式是创建多个线程。然而，由于核心的增加，有许多线程的问题需要解决。最大的问题是线程代码不能很好的拓展到任意数目的核心。你不能创建很多的线程，然后认为程序应该运行的很好。你需要知道的是你无法知道具体使用多少数量的核心才是高效的，程序自己去计算这个数量是一件很有挑战性的事情。即使你得到了正确的数字，那么这么多线程之间不能干扰且高效运行，仍然具有很大的难度。

所以，总结一下，就是说需要一种更好的方式来利用计算机的多和特性。单个程序能够执行的工作量能够动态的变化，以适应操作系统条件的不断变化。解决的办法还需要简单，不能增加额外的工作量。值得庆幸的是我大 Apple 已经解决了这些问题，你们快来膜拜并学习吧。


### 抛弃线程

尽管线程已经存在很久并且继续被使用，它们没有解决如何弹性的执行任务的普遍问题。创建可动态扩展线程对于开发者来说很复杂！一个问题是你必须决定开启多少线程，并且当操作系统环境改变时动态的改变线程数量。另一个问题是你的应用程序需要假定创建与维护这些线程的花销。

为了不依赖线程，OS X 和 iOS 采用异步的方式来解决这些问题，异步已经存在计算机中很长时间了，经常用来执行那些需要花费很多时间的任务，例如读取磁盘文件。当调用时，异步方法在后台执行任务，在执行任务完成之前，异步方法已经返回。通常情况下，任务调起后台线程，然后任务完成时发送通知给调用者（通常为函数回调）。过去你需要自己实现，现在我大 Apple 为你实现了这种技术。


使用异步方法的技术之一为 GCD（大中枢派发）。这项技术会将你写在程序中的线程管理代码迁移到系统级别。你需要做的仅仅只是定义需要执行的任务并且将它添加到适当的调度队列。GCD 来创建线程并在线程上执行你的代码，由于线程管理现在是系统的一部分，GCD 接管了线程管理和任务执行，所以比传统的线程创建方式要更高效一些。

Operation Queue 是 Objective-C 对象，很像 dispatch queue。你定义想要执行的任务然后将其添加到 Operation Queue 中，它将负责任务的调度和执行。跟 GCD 一样，Operation Queue 为你处理所有的线程管理，并且确保高效的执行。

下面是相关的详细技术。

#### Dispatch Queue

Dispatch Queues 是一种基于 C 语言的自定义任务执行机制。dispatch queue 串行或并行地执行任务，但总是 FIFO 的，换句话说，dispatch queue 中任务的执行完成顺序与任务添加顺序是一致的。串行的 dispatch queue 同一时间只在一条线程上执行任务，需要等待上个任务完成，才能开始下个任务。并行的dispatch queue 同一时间执行多个任务，不需要等待上个任务完成。

dispatch queue 有以下好处：

- 简明的编程接口
- 自动和全方位的线程池管理
- They provide the speed of tuned assembly.（应该是指优先级吧）
- 更好的内存利用（因为线程栈不在应用程序内存中一直保持）加载时不会中断内核
- 任务的异步调用不会导致死锁
- 竞争条件下合适的粒度
- 串行队列提供更加有效的同步机制

提交到 dispatch queue 的任务必须封装在一个函数或 block 对象。block 是 C 语言功能，类似函数指针的概念，但是有一些额外的优点。你通常定义 block 在另一个函数或者方法中以便于获取获取它们的变量，而不是在自己的变量范围内。当你提交任务到 queue 时，block 还可以被复制到堆上。这些语法使得能够用很少的代码实现动态的任务。

#### Dispatch Sources

Dispatch Source 是用于异步处理特殊类型系统事件的基于 C 语言的机制。一个 dispatch source 封装特殊类型系统事件的有关信息，当发生该事件时，向 dispatch source 提交特殊的 block 或函数。你可以使用 dispatch source 来监听一下系统事件：

- 计时器
- 信号处理描述符相关的进程事件
- Mach 端口事件
- 自定义的触发事件

#### Operation Queues

Cocoa 中的 Operation Queue 与并发 dispatch Queue 等同，由 NSOperationQueue 类实现。dispatch queue 总是按照先进先出的顺序执行任务，Operation queues 在决定任务执行顺序时会考虑其他的因素，你可以使用它来创建复杂的任务执行顺序。

提交至 Operation queue 的对象必须是 NSOperation 类的实例。Operation 对象封装执行的任务以及所需的数据。因为 NSOperation 类本质上是抽象基类，所以通常需要自定义自己的子类来执行任务。然而， Foundation Framework 提供了一些基本的子类，可以用来直接执行任务。

Operation 对象生成键值观察 （KVO）通知，是一种监听任务进度非常有用的方式。虽然操作队列总是并发的执行任务，不过当你需要时可以添加附属选项保证串行执行。


### 异步设计技术


在你重新考虑设计代码以支持并发时，你应该问问自己是否有这个必要。并发可以使主线程更加有效的响应用户事件，确保流畅。还能够在相同时间利用更多的内核来做更多的工作。

然而，它也会增加开销和代码量，增加编码和 Debug 难度。

由于增加了复杂性，并发不是在产品周期快结束时需要添加到程序中的一个 feature，想要做的正确，需要仔细考虑你的程序执行的任务和执行这些任务时所采用的数据结构。如果做的不好，你可能会发现代码比以前更慢了，带给用户的好处并不多。因此，你需要好好考虑一下。

每一个程序都有不同的需求和任务去执行。仅仅一份文档不可能告诉你如何设计你的程序和相关的任务。但是，下面各节尝试提供一些指导，帮助你在设计过程中做出正确的选择。

#### 定义应用程序预期的行为

在考虑程序中加入并发性之前，你总是应该从定义程序正确的行为开始。了解你的程序预期的行为，在之后的设计中可以帮助你验证你的设计。通过引入并发，会得到一些有关预期性能好处的想法。

需要做的第一件事，罗列出所有程序要做的任务以及相关的数据结构。最初，你可能想要从用户的点击事件任务开始罗列，这些任务提供了很清楚的起始点。你更应该罗列其他无需用户交互的应用程序任务，比如基于计时器的任务。

当你整理出高级别任务的列表后，将任务分解为完成任务必须的一系列步骤，在这个阶段，应该是主要是对数据或者对象做一些修改，以及这些修改如何影响程序的整体状态。你还应该注意对象和数据结构之间的依赖关系，注意对一个对象的修改是否影响其他对象。

#### 分解出可执行的工作单元

在考虑程序的任务时，你应该已经能够记住哪些代码并发处理时高效一些。如果在任务中更改了某些步骤的执行顺序，任务执行结果会改变，那么你可能需要考虑串行执行。如果任务的执行结果与任务中的步骤执行顺序无关，那么你可以使用并发来提高性能。这种情况下，你将任务拆分出一步一步执行的单元，然后将它们封装成 block 或者 Operation 对象分发到对应的队列。

对于你确认的任务中的每个执行单元，开始执行时不需要过多的担心工作量。即使开启线程需要一定的开销，但是 dispatch queue 和 Operation queue 的一个优点就是在多数情况下比传统线程的开销要小的多。所以，在使用队列执行一些很小的工作单元时，效率高于你使用线程。当然，你需要衡量实际的效率来调整任务的大小，但是在一开始，没必要考虑任务单元是不是太小了。


#### 决定你需要的队列

现在你的任务已经拆分为工作单元，并且用 block 或者 Operation 对象封装起来了，你需要定义你执行的队列。对于一个给定的任务，检查 block 或 operation 对象，以及执行任务的顺序，确保是正确的。

如果使用 block 实现任务，你可以向一个串行的或并行的队列添加 block。如果对于执行顺序有特殊的要求，你应该使用串行的队列。如果工作单元对于执行顺序没有要求，你可以使用并发的队列或者多个不同的并发队列，这个取决于你的需求。

如果使用 operation 对象，那么队列的选择不如配置对象有趣。想要串行的执行 operation 对象，你必须要处理这些对象之间的依赖关系，依赖项会阻止操作继续执行，直到所依赖的对象完成它们的工作。

#### 提高效率的小贴士

除了简洁的拆分你的代码为更小的任务，并将它们添加到一个队列，还有其他一些方法可以改善代码的整体效率:

- **如果内存占用是一个影响因素，考虑直接在任务代码中计算需要的值。**如果你的程序已经占用了很大内存，直接在代码中计算会比存主存中加载缓存要快的多。直接计算使用处理器核心的寄存器和缓存，比主存要快。当然，你应该做一些性能测试，然后决定是否要这样做。
- **尽早的识别出串行任务，并且使它们并发。** 如果任务因为共同依赖于某些公共资源，从而必须串行执行，那么你需要更改你的设计，移除这种共享关系，你可能会考虑为每个请求复制资源或者完全移除依赖。
- **避免使用锁** dispatch queue 和 operation queue 的所提供的一些支持使得锁在大多数情况下是不必要的。为了避免使用锁来保护一些资源，指定一个串行队列（或 operation 对象的相互依赖性）用正确的顺序来执行任务。
- **尽可能的依赖于系统提供的框架** 实现并发的最佳方式就是使用系统内建的并发支持。许多框架内部使用线程和其他技术来实现并发行为。当定义一个任务后，检查下是不是 framework 已经提供了你正想要的函数或者方法。使用系统 API 能够节省你的时间并且提供最大程序的并发。

### 性能影响

operation queue ，dispatch queue 还有 dispatch source 都提供了更加简单的并发编程方式。然而这些技术并不能保证一定能够提高程序的性能或改善代码的效率。但是你仍然需要以一种合理的方式去使用并发，不要过度的使用操作系统资源。比如一次向 operation queue 提交 1000 个operation 对象，这样可能会导致内存分配不够，致使发生内存分页而降低效率。

在代码中引用并发之前，无论是使用队列还是线程，都应该采集一些基准的性能指标反映当前的程序性能。当使用并发后，采集并发后的性能指标与之前的基准进行比较，看并发的引入是否提高了程序性能，使用性能测试工具来检测。


### 并发的其他技巧

增加并发数量的最佳方式是将代码拆分为更小的模块。然而，这种方式并不能在一些情况下满足每一个程序的需求。依据你的任务，可能其他一些选项能够让你的应用程序在整体并发上提高。下面各节列出了一些其他的技术，可以考虑作为设计的一部分。

#### OpenCL 和并发
在 OS X 中，**Open Computing Language （OpenCL）** 是一种计算机图形处理的通用标准技术。如果你有一些定义好的大数据计算集合，OpenCL 是一种很好的技术。举个例子，你可能使用 OpenCL 在图像的每一个像素上执行筛选计算或者用它来做复杂的数学运算。换句话说，OpenCL 多用于并行的数据集运算。

#### 什么时候使用线程

虽然 operation queue 和 dispatch queue 是执行并发的首选方式，但这并不是万能的。依据你的应用程序，有的时候可能仍需要创建自定义的线程。如果需要自定义线程，那么尽可能使用更少的线程来执行特定的任务，不要使用线程做其他的操作。

线程仍然是实现运行在 real time 代码的最佳方式，dispatch queue 尽管会尽可能快速的执行任务，但是仍然不能解决 real time 约束。如果你需要更多线程运行在后台的预计行为，线程通常会提供更好的选择。

不过，使用线程时仍然要再次确保是必要的。














