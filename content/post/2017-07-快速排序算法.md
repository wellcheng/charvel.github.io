---
layout: post
title: 常用排序算法：快速排序算法
date: 2017-07-02 18:10:26 +0800

tags: [算法]
---

快速排序算法，简称快排，其应用了递归的思想，现选择一个基准值 baseValue，然后利用这个 baseValue 将代排序的序列分割为两部分，左边是小于 base 的，右边是大于 base 的（这里以从小到大排序为例）。

接着，递归调用左边的部分和右边部分，最终递归下去，每个部分会只有一个元素，一个元素自然是已经排好序的。然后将这些小片段 join 起来，就是一个完整的有序序列。

<!-- more -->

## 一个快排序方法

快速排序也是分好多趟，每一趟都是使用最快的方法，将整个序列划分为两部分，前部分中每个值都比 base 小，后部分每个值都比 base 大。

基于这个思想，快排序有不同的实现。

### 第一个元素为基数

这个是我在《啊哈！算法》中看到的实现，选中第一个元素作为 base，然后从右边开始，找到第一个小于 base 的值，再从最左边开始找到第一个大于 base 的值，交换两者。接着继续从右找完从左找，找到后交换，如果左右相遇，先记住相遇位置，从这个位置开始，左边的序列都要比 base 小，右边的序列都要比 base 大，然后将 base 与这个相遇位置的值交换，就完成了第一次基准数归位。

如下图，第一个值 6 作为 base，i 是从左到右的游标，j 是从右到左的游标。

```
	i									j
	6	1	2	7	9	3	4	5	10	8
   	↑
   base
```

1.  j 先移动，找第一个小于 base 的值，即 5

```
	i							j
	6	1	2	7	9	3	4	5	10	8
   	↑
   base
```

2.  接着 i 开始移动，找到第一个比 base 大的值，即 7

```
				i				j
	6	1	2	7	9	3	4	5	10	8
   	↑
   base
```

3.  两者都寻找完毕，记做一次 match，交换两者

```
				i				j
	6	1	2	5	9	3	4	7	10	8
   	↑			↑				↑
   base
```

4.  重复步骤 1 和步骤 2。有一点需要注意，步骤 1 和 2 在移动时，始终要保持 i < j，也就是两人不能碰头。
5.  这里 j 继续走会找到 4 ，i 找到 9，9 和 4 交换，再继续，j 找到 3，i 再走一步，与 j 碰头。碰头后，需要将碰头位置与 base 交换。最终如下：

```
					   ij
	3	1	2	5	4	6	9	7	10	8
   						↑		
					   base
```

经过上面这些步骤，我们成功将 【	6、1、2、7、9、3、4、5、10、8】 这个序列分为了三部分：

-   【3、1、2、5、4】
-   【6】
-   【9、7、10、8】

接下来，只需要将第一部分和第三部分，分别处理为从小大排序，然后与中间部分的 6 拼接，那么整个序列就都是有序的。这个也是快排序递归的思想。

###  递归

递归思想，主要是两点：

1.  从宏观上，找到类比性，比如我们现在的第一部分序列 【3、1、2、5、4】与原来的整个序列 【	6、1、2、7、9、3、4、5、10、8】，是很类似的，都是几个无序值。因此我们怎么处理大序列，就如何处理小序列。
2.  从微观上讲，递归递归，不能无限递归下去，递归是将规模问题逐层下降到小问题上。

### 分区

快排序的核心是分区，也就是刚才上面寻找 base，划分区间的这个步骤。

用代码描述刚才的步骤：

```Swift
// 给定待排序数组，以及区间，给出数组中从 lhs 到 rhs 这个区间的 base 值，并且数组已经被 base 划分完成
func partition(arr:inout [Int], lhs:Int, rhs:Int) -> Int {
  // 使用 lhs 即最左边的数作为 base 
  var base = lhs
  let baseValue = arr[base]

  // 只有当没碰头时，才会先从右到左，再从左到右
  while (lhs != rhs) {
    // 从右到左
    while arr[rhs] > baseValue && lhs < rhs {
      rhs += 1
    }
    // 得到了第一个满足 arr[rhs] < baseValue 的 rhs 游标, 所以退出 while 循环
    
    // 从左到右
    while arr[lhs] < baseValue && lhs < rhs {
      lhs += 1
    }
    // 得到了第一个满足 arr[lhs] > baseValue 的 rhs 游标, 所以退出 while 循环    
    
    // 退出上面两个 while 循环，还有一种可能，就是 lhs < rhs 这个条件不满足，右因为 lhs 一开始小于 rhs，所以此时 lhs 可能等于 rhs
    if lhs < rhs {
      // 
      arr.swapAt(lhs, rhs)
    }
    
    // 当 lhs 和 rhs 还未相遇时，继续执行 while 循环
  }
  
  // 由于 lhs 与 rhs 相遇，退出了上面的 while 循环
  arr.swapAt(base, lhs)
  
  // 此时，在 arr 中给定的原 lhs 和 rhs 的区间里，已经被 base 划分为两块了
  return lhs
}
```

有了 partition 函数，就很方便地实现快排序了：

```swift
func quickSort(arr: inout [Int]) {
  func partition () {
    ...
  }
  
  func sort(arr: inout [Int], lhs:Int. rhs:Int) {
    if lhs < rhs {
      let base = partition(arr, lhs, rhs)
      sort(arr, lhs, base-1)
      sort(arr, base+1, rhs)      
    }
  }
  
  sort(arr, 0, arr.count-1)
}
```

partition 在不断地分区时，最小区间可能只有一个元素，那么此时该元素就是已经排好序的，如果是两个元素，那么右边的游标左移动后就立刻与 lhs 相遇，因此 base 产生一个空序列与单元素序列，空序列无需处理，单元素序列刚才已经说过。仍然按照上面的例子，对整块原始序列进行分析：

```swift
【6、1、2、7、9、3、4、5、10、8】
  【3，1，2，5，4】
    【2，1】
    	【1】
        	【1】base
    	【2】base
    【3】base
    【5，4】
    	【4】
    		【4】base
    	【5】base
  【6】base
  【9，7，10，8】
  	【8，7】
  		【7】
  			【7】base
  		【8】base
  	【9】base
  	【10】
  		【10】base

/**
如上示意图，递归到最下面，都是单元素作为 base 基准值
从上到下，把所有 base 合起来，就是1-10 的有序序列了。
*/ 

```

## 另一种 partition 方法

刚才是将第一个元素作为 base，现在尝试下将最后一个元素作为 base

```swift
    func partition( arr: inout [Int], left lhs: Int, right rhs: Int) -> Int {
        
        // 下一个可能要被交换的位置
        var rightBaseIndex = lhs
        
        // 直接使用最右边的元素作为基准
        let pivotValue = arr[rhs]
        
        // 从左到右（除了最后的基准元素），循环移动小于等于基准元素的元素到数组的开头
        for i in lhs...rhs-1 {
            if arr[i] < pivotValue {
                arr.swapAt(i, rightBaseIndex)
                rightBaseIndex += 1
            }
        }
        arr.swapAt(rightBaseIndex, rhs)
        return rightBaseIndex;
    }
```

这个 partition 方法的原理，可以自行思考一下。🤔

>   rightBaseIndex 表示这个位置有可能将序列划分为两部分，前边是小于base的，后边是大于 base 的。
>
>   所以在遍历时，当值小于 base 时，rightBase 要往后走一步，这样总能保证 rightBase 左边都是小于的值。
>
>   遍历时遇到大的值，就跳过，rightBase 不能继续走，因为 rightBase 当前位置的值要比 base 大，而 rightBase 要保证左边的值都要小于 base，所以它只好等待在遍历时能再次遇到一个小于 base 的值，与当前这个大的值替换，从而使得自己能够更进一步。
>
>   上述规则执行到最后，也就是遍历完毕时，rightBase 的位置刚好是能够将序列划分的位置，因此需要与 base 交换。

## 一定要写这么麻烦的 portition 吗？

算法的奇妙就在于，使用一些技巧和思想，可以更快更少占资源地完成任务。

如果不考虑空间复杂度，那么完全可以随便选一个 base，遍历所有元素，小于的单独放在一个数组中，大于的放在另一个。递归后，将所有元素 merge 即可得到结果。

## 小结

理解了 partition 方法才是 quickSort 的核心，那么 quickSort 也就简单了。